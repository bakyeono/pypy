# Generated by tools/asdl_py.py
from rpython.tool.pairtype import extendabletype
from rpython.tool.sourcetools import func_with_new_name

from pypy.interpreter import typedef
from pypy.interpreter.baseobjspace import W_Root
from pypy.interpreter.error import OperationError, oefmt
from pypy.interpreter.gateway import interp2app


def raise_attriberr(space, w_obj, name):
    raise oefmt(space.w_AttributeError,
                "'%T' object has no attribute '%s'", w_obj, name)


def check_string(space, w_obj):
    if not (space.isinstance_w(w_obj, space.w_str) or
            space.isinstance_w(w_obj, space.w_unicode)):
        raise OperationError(space.w_TypeError, space.wrap(
                'AST string must be of type str or unicode'))
    return w_obj

def get_field(space, w_node, name, optional):
    w_obj = w_node.getdictvalue(space, name)
    if w_obj is None and not optional:
        raise oefmt(space.w_TypeError,
                "required field \"%s\" missing from %T", name, w_node)
    return w_obj


class AST(object):
    __metaclass__ = extendabletype

    def walkabout(self, visitor):
        raise AssertionError("walkabout() implementation not provided")

    def mutate_over(self, visitor):
        raise AssertionError("mutate_over() implementation not provided")


class NodeVisitorNotImplemented(Exception):
    pass


class _FieldsWrapper(W_Root):
    "Hack around the fact we can't store tuples on a TypeDef."

    def __init__(self, fields):
        self.fields = fields

    def __spacebind__(self, space):
        return space.newtuple([space.wrap(field) for field in self.fields])


class W_AST(W_Root):
    w_dict = None

    def getdict(self, space):
        if self.w_dict is None:
            self.w_dict = space.newdict(instance=True)
        return self.w_dict

    def reduce_w(self, space):
        w_dict = self.w_dict
        if w_dict is None:
            w_dict = space.newdict()
        w_type = space.type(self)
        w_fields = space.getattr(w_type, space.wrap("_fields"))
        for w_name in space.fixedview(w_fields):
            try:
                space.setitem(w_dict, w_name,
                          space.getattr(self, w_name))
            except OperationError:
                pass
        w_attrs = space.findattr(w_type, space.wrap("_attributes"))
        if w_attrs:
            for w_name in space.fixedview(w_attrs):
                try:
                    space.setitem(w_dict, w_name,
                              space.getattr(self, w_name))
                except OperationError:
                    pass
        return space.newtuple([space.type(self),
                               space.newtuple([]),
                               w_dict])

    def setstate_w(self, space, w_state):
        for w_name in space.unpackiterable(w_state):
            space.setattr(self, w_name,
                          space.getitem(w_state, w_name))

def W_AST_new(space, w_type, __args__):
    node = space.allocate_instance(W_AST, w_type)
    return space.wrap(node)

def W_AST_init(space, w_self, __args__):
    args_w, kwargs_w = __args__.unpack()
    fields_w = space.fixedview(space.getattr(space.type(w_self),
                               space.wrap("_fields")))
    num_fields = len(fields_w) if fields_w else 0
    if args_w and len(args_w) != num_fields:
        if num_fields == 0:
            raise oefmt(space.w_TypeError,
                "%T constructor takes 0 positional arguments", w_self)
        elif num_fields == 1:
            raise oefmt(space.w_TypeError,
                "%T constructor takes either 0 or %d positional argument", w_self, num_fields)
        else:
            raise oefmt(space.w_TypeError,
                "%T constructor takes either 0 or %d positional arguments", w_self, num_fields)
    if args_w:
        for i, w_field in enumerate(fields_w):
            space.setattr(w_self, w_field, args_w[i])
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)


W_AST.typedef = typedef.TypeDef("_ast.AST",
    _fields=_FieldsWrapper([]),
    _attributes=_FieldsWrapper([]),
    __reduce__=interp2app(W_AST.reduce_w),
    __setstate__=interp2app(W_AST.setstate_w),
    __dict__ = typedef.GetSetProperty(typedef.descr_get_dict,
                                      typedef.descr_set_dict, cls=W_AST),
    __new__=interp2app(W_AST_new),
    __init__=interp2app(W_AST_init),
)

class State:
    AST_TYPES = []

    @classmethod
    def ast_type(cls, name, base, fields, attributes=None):
        cls.AST_TYPES.append((name, base, fields, attributes))

    def __init__(self, space):
        self.w_AST = space.gettypeobject(W_AST.typedef)
        for (name, base, fields, attributes) in self.AST_TYPES:
            self.make_new_type(space, name, base, fields, attributes)
        
    def make_new_type(self, space, name, base, fields, attributes):
        w_base = getattr(self, 'w_%s' % base)
        w_dict = space.newdict()
        space.setitem_str(w_dict, '__module__', space.wrap('_ast'))
        if fields is not None:
            space.setitem_str(w_dict, "_fields",
                              space.newtuple([space.wrap(f) for f in fields]))
        if attributes is not None:
            space.setitem_str(w_dict, "_attributes",
                              space.newtuple([space.wrap(a) for a in attributes]))
        w_type = space.call_function(
            space.w_type, 
            space.wrap(name), space.newtuple([w_base]), w_dict)
        setattr(self, 'w_%s' % name, w_type)

def get(space):
    return space.fromcache(State)

class mod(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.is_w(w_node, space.w_None):
            return None
        if space.isinstance_w(w_node, get(space).w_Module):
            return Module.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Interactive):
            return Interactive.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Expression):
            return Expression.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Suite):
            return Suite.from_object(space, w_node)
        raise oefmt(space.w_TypeError,
                "Expected mod node, got %T", w_node)
State.ast_type('mod', 'AST', None, [])

class Module(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Module(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Module(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Module)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        return Module(_body)

State.ast_type('Module', 'mod', ['body'])


class Interactive(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Interactive(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Interactive(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Interactive)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        return Interactive(_body)

State.ast_type('Interactive', 'mod', ['body'])


class Expression(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Expression(self)

    def mutate_over(self, visitor):
        self.body = self.body.mutate_over(visitor)
        return visitor.visit_Expression(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Expression)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        _body = expr.from_object(space, w_body)
        return Expression(_body)

State.ast_type('Expression', 'mod', ['body'])


class Suite(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Suite(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Suite(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Suite)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        return Suite(_body)

State.ast_type('Suite', 'mod', ['body'])


class stmt(AST):

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset

    @staticmethod
    def from_object(space, w_node):
        if space.is_w(w_node, space.w_None):
            return None
        if space.isinstance_w(w_node, get(space).w_FunctionDef):
            return FunctionDef.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_ClassDef):
            return ClassDef.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Return):
            return Return.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Delete):
            return Delete.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Assign):
            return Assign.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_AugAssign):
            return AugAssign.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Print):
            return Print.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_For):
            return For.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_While):
            return While.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_If):
            return If.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_With):
            return With.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Raise):
            return Raise.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_TryExcept):
            return TryExcept.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_TryFinally):
            return TryFinally.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Assert):
            return Assert.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Import):
            return Import.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_ImportFrom):
            return ImportFrom.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Exec):
            return Exec.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Global):
            return Global.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Expr):
            return Expr.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Pass):
            return Pass.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Break):
            return Break.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Continue):
            return Continue.from_object(space, w_node)
        raise oefmt(space.w_TypeError,
                "Expected stmt node, got %T", w_node)
State.ast_type('stmt', 'AST', None, ['lineno', 'col_offset'])

class FunctionDef(stmt):

    def __init__(self, name, args, body, decorator_list, returns, lineno, col_offset):
        self.name = name
        self.args = args
        self.body = body
        self.decorator_list = decorator_list
<<<<<<< mine
        self.w_decorator_list = None
        self.returns = returns
=======
>>>>>>> theirs
        stmt.__init__(self, lineno, col_offset)
<<<<<<< mine
        self.initialization_state = 127
=======
>>>>>>> theirs

    def walkabout(self, visitor):
        visitor.visit_FunctionDef(self)

    def mutate_over(self, visitor):
        self.args = self.args.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.decorator_list:
            visitor._mutate_sequence(self.decorator_list)
        if self.returns:
            self.returns = self.returns.mutate_over(visitor)
        return visitor.visit_FunctionDef(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~64) ^ 63:
            self.missing_field(space, ['lineno', 'col_offset', 'name', 'args', 'body', 'decorator_list', None], 'FunctionDef')
        else:
            if not self.initialization_state & 64:
                self.returns = None
        self.args.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_decorator_list
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.decorator_list = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.decorator_list = None
        if self.decorator_list is not None:
            for node in self.decorator_list:
                node.sync_app_attrs(space)
        if self.returns:
            self.returns.sync_app_attrs(space)
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_FunctionDef)
        w_name = space.wrap(self.name)  # identifier
        space.setattr(w_node, space.wrap('name'), w_name)
        w_args = self.args.to_object(space)  # arguments
        space.setattr(w_node, space.wrap('args'), w_args)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.decorator_list is None:
            decorator_list_w = []
        else:
            decorator_list_w = [node.to_object(space) for node in self.decorator_list] # expr
        w_decorator_list = space.newlist(decorator_list_w)
        space.setattr(w_node, space.wrap('decorator_list'), w_decorator_list)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_name = get_field(space, w_node, 'name', False)
        w_args = get_field(space, w_node, 'args', False)
        w_body = get_field(space, w_node, 'body', False)
        w_decorator_list = get_field(space, w_node, 'decorator_list', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _name = space.realstr_w(w_name)
        _args = arguments.from_object(space, w_args)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        decorator_list_w = space.unpackiterable(w_decorator_list)
        _decorator_list = [expr.from_object(space, w_item) for w_item in decorator_list_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return FunctionDef(_name, _args, _body, _decorator_list, _lineno, _col_offset)

State.ast_type('FunctionDef', 'stmt', ['name', 'args', 'body', 'decorator_list'])
>>>>>>> theirs


class ClassDef(stmt):

    def __init__(self, name, bases, keywords, starargs, kwargs, body, decorator_list, lineno, col_offset):
        self.name = name
        self.bases = bases
<<<<<<< mine
        self.w_bases = None
        self.keywords = keywords
        self.w_keywords = None
        self.starargs = starargs
        self.kwargs = kwargs
=======
>>>>>>> theirs
        self.body = body
        self.decorator_list = decorator_list
        stmt.__init__(self, lineno, col_offset)
<<<<<<< mine
        self.initialization_state = 511
=======
>>>>>>> theirs

    def walkabout(self, visitor):
        visitor.visit_ClassDef(self)

    def mutate_over(self, visitor):
        if self.bases:
            visitor._mutate_sequence(self.bases)
        if self.keywords:
            visitor._mutate_sequence(self.keywords)
        if self.starargs:
            self.starargs = self.starargs.mutate_over(visitor)
        if self.kwargs:
            self.kwargs = self.kwargs.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.decorator_list:
            visitor._mutate_sequence(self.decorator_list)
        return visitor.visit_ClassDef(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~96) ^ 415:
            self.missing_field(space, ['lineno', 'col_offset', 'name', 'bases', 'keywords', None, None, 'body', 'decorator_list'], 'ClassDef')
        else:
            if not self.initialization_state & 32:
                self.starargs = None
            if not self.initialization_state & 64:
                self.kwargs = None
        w_list = self.w_bases
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.bases = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.bases = None
        if self.bases is not None:
            for node in self.bases:
                node.sync_app_attrs(space)
        w_list = self.w_keywords
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.keywords = [space.interp_w(keyword, w_obj) for w_obj in list_w]
            else:
                self.keywords = None
        if self.keywords is not None:
            for node in self.keywords:
                node.sync_app_attrs(space)
        if self.starargs:
            self.starargs.sync_app_attrs(space)
        if self.kwargs:
            self.kwargs.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_decorator_list
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.decorator_list = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.decorator_list = None
        if self.decorator_list is not None:
            for node in self.decorator_list:
                node.sync_app_attrs(space)
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_ClassDef)
        w_name = space.wrap(self.name)  # identifier
        space.setattr(w_node, space.wrap('name'), w_name)
        if self.bases is None:
            bases_w = []
        else:
            bases_w = [node.to_object(space) for node in self.bases] # expr
        w_bases = space.newlist(bases_w)
        space.setattr(w_node, space.wrap('bases'), w_bases)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.decorator_list is None:
            decorator_list_w = []
        else:
            decorator_list_w = [node.to_object(space) for node in self.decorator_list] # expr
        w_decorator_list = space.newlist(decorator_list_w)
        space.setattr(w_node, space.wrap('decorator_list'), w_decorator_list)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_name = get_field(space, w_node, 'name', False)
        w_bases = get_field(space, w_node, 'bases', False)
        w_body = get_field(space, w_node, 'body', False)
        w_decorator_list = get_field(space, w_node, 'decorator_list', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _name = space.realstr_w(w_name)
        bases_w = space.unpackiterable(w_bases)
        _bases = [expr.from_object(space, w_item) for w_item in bases_w]
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        decorator_list_w = space.unpackiterable(w_decorator_list)
        _decorator_list = [expr.from_object(space, w_item) for w_item in decorator_list_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return ClassDef(_name, _bases, _body, _decorator_list, _lineno, _col_offset)

State.ast_type('ClassDef', 'stmt', ['name', 'bases', 'body', 'decorator_list'])
>>>>>>> theirs


class Return(stmt):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Return(self)

    def mutate_over(self, visitor):
        if self.value:
            self.value = self.value.mutate_over(visitor)
        return visitor.visit_Return(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Return)
        w_value = self.value.to_object(space) if self.value is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = expr.from_object(space, w_value)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Return(_value, _lineno, _col_offset)

State.ast_type('Return', 'stmt', ['value'])


class Delete(stmt):

    def __init__(self, targets, lineno, col_offset):
        self.targets = targets
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Delete(self)

    def mutate_over(self, visitor):
        if self.targets:
            visitor._mutate_sequence(self.targets)
        return visitor.visit_Delete(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Delete)
        if self.targets is None:
            targets_w = []
        else:
            targets_w = [node.to_object(space) for node in self.targets] # expr
        w_targets = space.newlist(targets_w)
        space.setattr(w_node, space.wrap('targets'), w_targets)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_targets = get_field(space, w_node, 'targets', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        targets_w = space.unpackiterable(w_targets)
        _targets = [expr.from_object(space, w_item) for w_item in targets_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Delete(_targets, _lineno, _col_offset)

State.ast_type('Delete', 'stmt', ['targets'])


class Assign(stmt):

    def __init__(self, targets, value, lineno, col_offset):
        self.targets = targets
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Assign(self)

    def mutate_over(self, visitor):
        if self.targets:
            visitor._mutate_sequence(self.targets)
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Assign(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Assign)
        if self.targets is None:
            targets_w = []
        else:
            targets_w = [node.to_object(space) for node in self.targets] # expr
        w_targets = space.newlist(targets_w)
        space.setattr(w_node, space.wrap('targets'), w_targets)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_targets = get_field(space, w_node, 'targets', False)
        w_value = get_field(space, w_node, 'value', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        targets_w = space.unpackiterable(w_targets)
        _targets = [expr.from_object(space, w_item) for w_item in targets_w]
        _value = expr.from_object(space, w_value)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Assign(_targets, _value, _lineno, _col_offset)

State.ast_type('Assign', 'stmt', ['targets', 'value'])


class AugAssign(stmt):

    def __init__(self, target, op, value, lineno, col_offset):
        self.target = target
        self.op = op
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_AugAssign(self)

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_AugAssign(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_AugAssign)
        w_target = self.target.to_object(space)  # expr
        space.setattr(w_node, space.wrap('target'), w_target)
        w_op = operator_to_class[self.op - 1]().to_object(space)  # operator
        space.setattr(w_node, space.wrap('op'), w_op)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_target = get_field(space, w_node, 'target', False)
        w_op = get_field(space, w_node, 'op', False)
        w_value = get_field(space, w_node, 'value', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _target = expr.from_object(space, w_target)
        _op = operator.from_object(space, w_op)
        _value = expr.from_object(space, w_value)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return AugAssign(_target, _op, _value, _lineno, _col_offset)

State.ast_type('AugAssign', 'stmt', ['target', 'op', 'value'])


<<<<<<< mine
=======
class Print(stmt):

    def __init__(self, dest, values, nl, lineno, col_offset):
        self.dest = dest
        self.values = values
        self.nl = nl
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Print(self)

    def mutate_over(self, visitor):
        if self.dest:
            self.dest = self.dest.mutate_over(visitor)
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_Print(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Print)
        w_dest = self.dest.to_object(space) if self.dest is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('dest'), w_dest)
        if self.values is None:
            values_w = []
        else:
            values_w = [node.to_object(space) for node in self.values] # expr
        w_values = space.newlist(values_w)
        space.setattr(w_node, space.wrap('values'), w_values)
        w_nl = space.wrap(self.nl)  # bool
        space.setattr(w_node, space.wrap('nl'), w_nl)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_dest = get_field(space, w_node, 'dest', True)
        w_values = get_field(space, w_node, 'values', False)
        w_nl = get_field(space, w_node, 'nl', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _dest = expr.from_object(space, w_dest)
        values_w = space.unpackiterable(w_values)
        _values = [expr.from_object(space, w_item) for w_item in values_w]
        _nl = space.bool_w(w_nl)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Print(_dest, _values, _nl, _lineno, _col_offset)

State.ast_type('Print', 'stmt', ['dest', 'values', 'nl'])


>>>>>>> theirs
class For(stmt):

    def __init__(self, target, iter, body, orelse, lineno, col_offset):
        self.target = target
        self.iter = iter
        self.body = body
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_For(self)

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.iter = self.iter.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_For(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_For)
        w_target = self.target.to_object(space)  # expr
        space.setattr(w_node, space.wrap('target'), w_target)
        w_iter = self.iter.to_object(space)  # expr
        space.setattr(w_node, space.wrap('iter'), w_iter)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_target = get_field(space, w_node, 'target', False)
        w_iter = get_field(space, w_node, 'iter', False)
        w_body = get_field(space, w_node, 'body', False)
        w_orelse = get_field(space, w_node, 'orelse', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _target = expr.from_object(space, w_target)
        _iter = expr.from_object(space, w_iter)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        orelse_w = space.unpackiterable(w_orelse)
        _orelse = [stmt.from_object(space, w_item) for w_item in orelse_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return For(_target, _iter, _body, _orelse, _lineno, _col_offset)

State.ast_type('For', 'stmt', ['target', 'iter', 'body', 'orelse'])


class While(stmt):

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_While(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_While(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_While)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_test = get_field(space, w_node, 'test', False)
        w_body = get_field(space, w_node, 'body', False)
        w_orelse = get_field(space, w_node, 'orelse', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _test = expr.from_object(space, w_test)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        orelse_w = space.unpackiterable(w_orelse)
        _orelse = [stmt.from_object(space, w_item) for w_item in orelse_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return While(_test, _body, _orelse, _lineno, _col_offset)

State.ast_type('While', 'stmt', ['test', 'body', 'orelse'])


class If(stmt):

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_If(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_If(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_If)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_test = get_field(space, w_node, 'test', False)
        w_body = get_field(space, w_node, 'body', False)
        w_orelse = get_field(space, w_node, 'orelse', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _test = expr.from_object(space, w_test)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        orelse_w = space.unpackiterable(w_orelse)
        _orelse = [stmt.from_object(space, w_item) for w_item in orelse_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return If(_test, _body, _orelse, _lineno, _col_offset)

State.ast_type('If', 'stmt', ['test', 'body', 'orelse'])


class With(stmt):

    def __init__(self, context_expr, optional_vars, body, lineno, col_offset):
        self.context_expr = context_expr
        self.optional_vars = optional_vars
        self.body = body
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_With(self)

    def mutate_over(self, visitor):
        self.context_expr = self.context_expr.mutate_over(visitor)
        if self.optional_vars:
            self.optional_vars = self.optional_vars.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_With(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_With)
        w_context_expr = self.context_expr.to_object(space)  # expr
        space.setattr(w_node, space.wrap('context_expr'), w_context_expr)
        w_optional_vars = self.optional_vars.to_object(space) if self.optional_vars is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('optional_vars'), w_optional_vars)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_context_expr = get_field(space, w_node, 'context_expr', False)
        w_optional_vars = get_field(space, w_node, 'optional_vars', True)
        w_body = get_field(space, w_node, 'body', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _context_expr = expr.from_object(space, w_context_expr)
        _optional_vars = expr.from_object(space, w_optional_vars)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return With(_context_expr, _optional_vars, _body, _lineno, _col_offset)

State.ast_type('With', 'stmt', ['context_expr', 'optional_vars', 'body'])


class Raise(stmt):

    def __init__(self, exc, cause, lineno, col_offset):
        self.exc = exc
        self.cause = cause
        stmt.__init__(self, lineno, col_offset)
<<<<<<< mine
        self.initialization_state = 15
=======
>>>>>>> theirs

    def walkabout(self, visitor):
        visitor.visit_Raise(self)

    def mutate_over(self, visitor):
        if self.exc:
            self.exc = self.exc.mutate_over(visitor)
        if self.cause:
            self.cause = self.cause.mutate_over(visitor)
        return visitor.visit_Raise(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~12) ^ 3:
            self.missing_field(space, ['lineno', 'col_offset', None, None], 'Raise')
        else:
            if not self.initialization_state & 4:
                self.exc = None
            if not self.initialization_state & 8:
                self.cause = None
        if self.exc:
            self.exc.sync_app_attrs(space)
        if self.cause:
            self.cause.sync_app_attrs(space)
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_Raise)
        w_type = self.type.to_object(space) if self.type is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('type'), w_type)
        w_inst = self.inst.to_object(space) if self.inst is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('inst'), w_inst)
        w_tback = self.tback.to_object(space) if self.tback is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('tback'), w_tback)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_type = get_field(space, w_node, 'type', True)
        w_inst = get_field(space, w_node, 'inst', True)
        w_tback = get_field(space, w_node, 'tback', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _type = expr.from_object(space, w_type)
        _inst = expr.from_object(space, w_inst)
        _tback = expr.from_object(space, w_tback)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Raise(_type, _inst, _tback, _lineno, _col_offset)

State.ast_type('Raise', 'stmt', ['type', 'inst', 'tback'])
>>>>>>> theirs


class TryExcept(stmt):

    def __init__(self, body, handlers, orelse, lineno, col_offset):
        self.body = body
        self.handlers = handlers
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_TryExcept(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.handlers:
            visitor._mutate_sequence(self.handlers)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_TryExcept(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_TryExcept)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.handlers is None:
            handlers_w = []
        else:
            handlers_w = [node.to_object(space) for node in self.handlers] # excepthandler
        w_handlers = space.newlist(handlers_w)
        space.setattr(w_node, space.wrap('handlers'), w_handlers)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        w_handlers = get_field(space, w_node, 'handlers', False)
        w_orelse = get_field(space, w_node, 'orelse', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        handlers_w = space.unpackiterable(w_handlers)
        _handlers = [excepthandler.from_object(space, w_item) for w_item in handlers_w]
        orelse_w = space.unpackiterable(w_orelse)
        _orelse = [stmt.from_object(space, w_item) for w_item in orelse_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return TryExcept(_body, _handlers, _orelse, _lineno, _col_offset)

State.ast_type('TryExcept', 'stmt', ['body', 'handlers', 'orelse'])


class TryFinally(stmt):

    def __init__(self, body, finalbody, lineno, col_offset):
        self.body = body
        self.finalbody = finalbody
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_TryFinally(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.finalbody:
            visitor._mutate_sequence(self.finalbody)
        return visitor.visit_TryFinally(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_TryFinally)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.finalbody is None:
            finalbody_w = []
        else:
            finalbody_w = [node.to_object(space) for node in self.finalbody] # stmt
        w_finalbody = space.newlist(finalbody_w)
        space.setattr(w_node, space.wrap('finalbody'), w_finalbody)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        w_finalbody = get_field(space, w_node, 'finalbody', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        finalbody_w = space.unpackiterable(w_finalbody)
        _finalbody = [stmt.from_object(space, w_item) for w_item in finalbody_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return TryFinally(_body, _finalbody, _lineno, _col_offset)

State.ast_type('TryFinally', 'stmt', ['body', 'finalbody'])


class Assert(stmt):

    def __init__(self, test, msg, lineno, col_offset):
        self.test = test
        self.msg = msg
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Assert(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.msg:
            self.msg = self.msg.mutate_over(visitor)
        return visitor.visit_Assert(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Assert)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        w_msg = self.msg.to_object(space) if self.msg is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('msg'), w_msg)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_test = get_field(space, w_node, 'test', False)
        w_msg = get_field(space, w_node, 'msg', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _test = expr.from_object(space, w_test)
        _msg = expr.from_object(space, w_msg)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Assert(_test, _msg, _lineno, _col_offset)

State.ast_type('Assert', 'stmt', ['test', 'msg'])


class Import(stmt):

    def __init__(self, names, lineno, col_offset):
        self.names = names
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Import(self)

    def mutate_over(self, visitor):
        if self.names:
            visitor._mutate_sequence(self.names)
        return visitor.visit_Import(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Import)
        if self.names is None:
            names_w = []
        else:
            names_w = [node.to_object(space) for node in self.names] # alias
        w_names = space.newlist(names_w)
        space.setattr(w_node, space.wrap('names'), w_names)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_names = get_field(space, w_node, 'names', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        names_w = space.unpackiterable(w_names)
        _names = [alias.from_object(space, w_item) for w_item in names_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Import(_names, _lineno, _col_offset)

State.ast_type('Import', 'stmt', ['names'])


class ImportFrom(stmt):

    def __init__(self, module, names, level, lineno, col_offset):
        self.module = module
        self.names = names
        self.level = level
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ImportFrom(self)

    def mutate_over(self, visitor):
        if self.names:
            visitor._mutate_sequence(self.names)
        return visitor.visit_ImportFrom(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ImportFrom)
        w_module = space.wrap(self.module)  # identifier
        space.setattr(w_node, space.wrap('module'), w_module)
        if self.names is None:
            names_w = []
        else:
            names_w = [node.to_object(space) for node in self.names] # alias
        w_names = space.newlist(names_w)
        space.setattr(w_node, space.wrap('names'), w_names)
        w_level = space.wrap(self.level)  # int
        space.setattr(w_node, space.wrap('level'), w_level)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_module = get_field(space, w_node, 'module', True)
        w_names = get_field(space, w_node, 'names', False)
        w_level = get_field(space, w_node, 'level', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _module = space.str_or_None_w(w_module)
        names_w = space.unpackiterable(w_names)
        _names = [alias.from_object(space, w_item) for w_item in names_w]
        _level = space.int_w(w_level)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return ImportFrom(_module, _names, _level, _lineno, _col_offset)

State.ast_type('ImportFrom', 'stmt', ['module', 'names', 'level'])


class Global(stmt):

    def __init__(self, names, lineno, col_offset):
        self.names = names
        self.w_names = None
        stmt.__init__(self, lineno, col_offset)
<<<<<<< mine
        self.initialization_state = 7
=======
>>>>>>> theirs

    def walkabout(self, visitor):
        visitor.visit_Global(self)

    def mutate_over(self, visitor):
        return visitor.visit_Global(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            self.missing_field(space, ['lineno', 'col_offset', 'names'], 'Global')
        else:
            pass
        w_list = self.w_names
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.names = [space.identifier_w(w_obj) for w_obj in list_w]
            else:
                self.names = None
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_Exec)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        w_globals = self.globals.to_object(space) if self.globals is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('globals'), w_globals)
        w_locals = self.locals.to_object(space) if self.locals is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('locals'), w_locals)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_body = get_field(space, w_node, 'body', False)
        w_globals = get_field(space, w_node, 'globals', True)
        w_locals = get_field(space, w_node, 'locals', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _body = expr.from_object(space, w_body)
        _globals = expr.from_object(space, w_globals)
        _locals = expr.from_object(space, w_locals)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Exec(_body, _globals, _locals, _lineno, _col_offset)

State.ast_type('Exec', 'stmt', ['body', 'globals', 'locals'])
>>>>>>> theirs


class Nonlocal(stmt):

    def __init__(self, names, lineno, col_offset):
        self.names = names
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Nonlocal(self)

    def mutate_over(self, visitor):
        return visitor.visit_Nonlocal(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            self.missing_field(space, ['lineno', 'col_offset', 'names'], 'Nonlocal')
        else:
            pass
        w_list = self.w_names
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.names = [space.identifier_w(w_obj) for w_obj in list_w]
            else:
                self.names = None
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_Global)
        if self.names is None:
            names_w = []
        else:
            names_w = [space.wrap(node) for node in self.names] # identifier
        w_names = space.newlist(names_w)
        space.setattr(w_node, space.wrap('names'), w_names)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_names = get_field(space, w_node, 'names', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        names_w = space.unpackiterable(w_names)
        _names = [space.realstr_w(w_item) for w_item in names_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Global(_names, _lineno, _col_offset)

State.ast_type('Global', 'stmt', ['names'])
>>>>>>> theirs


class Expr(stmt):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Expr(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Expr(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Expr)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = expr.from_object(space, w_value)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Expr(_value, _lineno, _col_offset)

State.ast_type('Expr', 'stmt', ['value'])


class Pass(stmt):

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Pass(self)

    def mutate_over(self, visitor):
        return visitor.visit_Pass(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Pass)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Pass(_lineno, _col_offset)

State.ast_type('Pass', 'stmt', [])


class Break(stmt):

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Break(self)

    def mutate_over(self, visitor):
        return visitor.visit_Break(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Break)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Break(_lineno, _col_offset)

State.ast_type('Break', 'stmt', [])


class Continue(stmt):

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Continue(self)

    def mutate_over(self, visitor):
        return visitor.visit_Continue(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Continue)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Continue(_lineno, _col_offset)

State.ast_type('Continue', 'stmt', [])


class expr(AST):

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset

    @staticmethod
    def from_object(space, w_node):
        if space.is_w(w_node, space.w_None):
            return None
        if space.isinstance_w(w_node, get(space).w_BoolOp):
            return BoolOp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_BinOp):
            return BinOp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_UnaryOp):
            return UnaryOp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Lambda):
            return Lambda.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_IfExp):
            return IfExp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Dict):
            return Dict.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Set):
            return Set.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_ListComp):
            return ListComp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_SetComp):
            return SetComp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_DictComp):
            return DictComp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_GeneratorExp):
            return GeneratorExp.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Yield):
            return Yield.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Compare):
            return Compare.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Call):
            return Call.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Repr):
            return Repr.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Num):
            return Num.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Str):
            return Str.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Attribute):
            return Attribute.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Subscript):
            return Subscript.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Name):
            return Name.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_List):
            return List.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Tuple):
            return Tuple.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Const):
            return Const.from_object(space, w_node)
        raise oefmt(space.w_TypeError,
                "Expected expr node, got %T", w_node)
State.ast_type('expr', 'AST', None, ['lineno', 'col_offset'])

class BoolOp(expr):

    def __init__(self, op, values, lineno, col_offset):
        self.op = op
        self.values = values
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_BoolOp(self)

    def mutate_over(self, visitor):
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_BoolOp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_BoolOp)
        w_op = boolop_to_class[self.op - 1]().to_object(space)  # boolop
        space.setattr(w_node, space.wrap('op'), w_op)
        if self.values is None:
            values_w = []
        else:
            values_w = [node.to_object(space) for node in self.values] # expr
        w_values = space.newlist(values_w)
        space.setattr(w_node, space.wrap('values'), w_values)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_op = get_field(space, w_node, 'op', False)
        w_values = get_field(space, w_node, 'values', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _op = boolop.from_object(space, w_op)
        values_w = space.unpackiterable(w_values)
        _values = [expr.from_object(space, w_item) for w_item in values_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return BoolOp(_op, _values, _lineno, _col_offset)

State.ast_type('BoolOp', 'expr', ['op', 'values'])


class BinOp(expr):

    def __init__(self, left, op, right, lineno, col_offset):
        self.left = left
        self.op = op
        self.right = right
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_BinOp(self)

    def mutate_over(self, visitor):
        self.left = self.left.mutate_over(visitor)
        self.right = self.right.mutate_over(visitor)
        return visitor.visit_BinOp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_BinOp)
        w_left = self.left.to_object(space)  # expr
        space.setattr(w_node, space.wrap('left'), w_left)
        w_op = operator_to_class[self.op - 1]().to_object(space)  # operator
        space.setattr(w_node, space.wrap('op'), w_op)
        w_right = self.right.to_object(space)  # expr
        space.setattr(w_node, space.wrap('right'), w_right)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_left = get_field(space, w_node, 'left', False)
        w_op = get_field(space, w_node, 'op', False)
        w_right = get_field(space, w_node, 'right', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _left = expr.from_object(space, w_left)
        _op = operator.from_object(space, w_op)
        _right = expr.from_object(space, w_right)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return BinOp(_left, _op, _right, _lineno, _col_offset)

State.ast_type('BinOp', 'expr', ['left', 'op', 'right'])


class UnaryOp(expr):

    def __init__(self, op, operand, lineno, col_offset):
        self.op = op
        self.operand = operand
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_UnaryOp(self)

    def mutate_over(self, visitor):
        self.operand = self.operand.mutate_over(visitor)
        return visitor.visit_UnaryOp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_UnaryOp)
        w_op = unaryop_to_class[self.op - 1]().to_object(space)  # unaryop
        space.setattr(w_node, space.wrap('op'), w_op)
        w_operand = self.operand.to_object(space)  # expr
        space.setattr(w_node, space.wrap('operand'), w_operand)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_op = get_field(space, w_node, 'op', False)
        w_operand = get_field(space, w_node, 'operand', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _op = unaryop.from_object(space, w_op)
        _operand = expr.from_object(space, w_operand)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return UnaryOp(_op, _operand, _lineno, _col_offset)

State.ast_type('UnaryOp', 'expr', ['op', 'operand'])


class Lambda(expr):

    def __init__(self, args, body, lineno, col_offset):
        self.args = args
        self.body = body
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Lambda(self)

    def mutate_over(self, visitor):
        self.args = self.args.mutate_over(visitor)
        self.body = self.body.mutate_over(visitor)
        return visitor.visit_Lambda(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Lambda)
        w_args = self.args.to_object(space)  # arguments
        space.setattr(w_node, space.wrap('args'), w_args)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_args = get_field(space, w_node, 'args', False)
        w_body = get_field(space, w_node, 'body', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _args = arguments.from_object(space, w_args)
        _body = expr.from_object(space, w_body)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Lambda(_args, _body, _lineno, _col_offset)

State.ast_type('Lambda', 'expr', ['args', 'body'])


class IfExp(expr):

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_IfExp(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        self.body = self.body.mutate_over(visitor)
        self.orelse = self.orelse.mutate_over(visitor)
        return visitor.visit_IfExp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_IfExp)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        w_orelse = self.orelse.to_object(space)  # expr
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_test = get_field(space, w_node, 'test', False)
        w_body = get_field(space, w_node, 'body', False)
        w_orelse = get_field(space, w_node, 'orelse', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _test = expr.from_object(space, w_test)
        _body = expr.from_object(space, w_body)
        _orelse = expr.from_object(space, w_orelse)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return IfExp(_test, _body, _orelse, _lineno, _col_offset)

State.ast_type('IfExp', 'expr', ['test', 'body', 'orelse'])


class Dict(expr):

    def __init__(self, keys, values, lineno, col_offset):
        self.keys = keys
        self.values = values
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Dict(self)

    def mutate_over(self, visitor):
        if self.keys:
            visitor._mutate_sequence(self.keys)
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_Dict(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Dict)
        if self.keys is None:
            keys_w = []
        else:
            keys_w = [node.to_object(space) for node in self.keys] # expr
        w_keys = space.newlist(keys_w)
        space.setattr(w_node, space.wrap('keys'), w_keys)
        if self.values is None:
            values_w = []
        else:
            values_w = [node.to_object(space) for node in self.values] # expr
        w_values = space.newlist(values_w)
        space.setattr(w_node, space.wrap('values'), w_values)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_keys = get_field(space, w_node, 'keys', False)
        w_values = get_field(space, w_node, 'values', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        keys_w = space.unpackiterable(w_keys)
        _keys = [expr.from_object(space, w_item) for w_item in keys_w]
        values_w = space.unpackiterable(w_values)
        _values = [expr.from_object(space, w_item) for w_item in values_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Dict(_keys, _values, _lineno, _col_offset)

State.ast_type('Dict', 'expr', ['keys', 'values'])


class Set(expr):

    def __init__(self, elts, lineno, col_offset):
        self.elts = elts
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Set(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_Set(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Set)
        if self.elts is None:
            elts_w = []
        else:
            elts_w = [node.to_object(space) for node in self.elts] # expr
        w_elts = space.newlist(elts_w)
        space.setattr(w_node, space.wrap('elts'), w_elts)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_elts = get_field(space, w_node, 'elts', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        elts_w = space.unpackiterable(w_elts)
        _elts = [expr.from_object(space, w_item) for w_item in elts_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Set(_elts, _lineno, _col_offset)

State.ast_type('Set', 'expr', ['elts'])


class ListComp(expr):

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ListComp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_ListComp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ListComp)
        w_elt = self.elt.to_object(space)  # expr
        space.setattr(w_node, space.wrap('elt'), w_elt)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_elt = get_field(space, w_node, 'elt', False)
        w_generators = get_field(space, w_node, 'generators', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _elt = expr.from_object(space, w_elt)
        generators_w = space.unpackiterable(w_generators)
        _generators = [comprehension.from_object(space, w_item) for w_item in generators_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return ListComp(_elt, _generators, _lineno, _col_offset)

State.ast_type('ListComp', 'expr', ['elt', 'generators'])


class SetComp(expr):

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_SetComp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_SetComp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_SetComp)
        w_elt = self.elt.to_object(space)  # expr
        space.setattr(w_node, space.wrap('elt'), w_elt)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_elt = get_field(space, w_node, 'elt', False)
        w_generators = get_field(space, w_node, 'generators', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _elt = expr.from_object(space, w_elt)
        generators_w = space.unpackiterable(w_generators)
        _generators = [comprehension.from_object(space, w_item) for w_item in generators_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return SetComp(_elt, _generators, _lineno, _col_offset)

State.ast_type('SetComp', 'expr', ['elt', 'generators'])


class DictComp(expr):

    def __init__(self, key, value, generators, lineno, col_offset):
        self.key = key
        self.value = value
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_DictComp(self)

    def mutate_over(self, visitor):
        self.key = self.key.mutate_over(visitor)
        self.value = self.value.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_DictComp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_DictComp)
        w_key = self.key.to_object(space)  # expr
        space.setattr(w_node, space.wrap('key'), w_key)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_key = get_field(space, w_node, 'key', False)
        w_value = get_field(space, w_node, 'value', False)
        w_generators = get_field(space, w_node, 'generators', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _key = expr.from_object(space, w_key)
        _value = expr.from_object(space, w_value)
        generators_w = space.unpackiterable(w_generators)
        _generators = [comprehension.from_object(space, w_item) for w_item in generators_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return DictComp(_key, _value, _generators, _lineno, _col_offset)

State.ast_type('DictComp', 'expr', ['key', 'value', 'generators'])


class GeneratorExp(expr):

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_GeneratorExp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_GeneratorExp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_GeneratorExp)
        w_elt = self.elt.to_object(space)  # expr
        space.setattr(w_node, space.wrap('elt'), w_elt)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_elt = get_field(space, w_node, 'elt', False)
        w_generators = get_field(space, w_node, 'generators', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _elt = expr.from_object(space, w_elt)
        generators_w = space.unpackiterable(w_generators)
        _generators = [comprehension.from_object(space, w_item) for w_item in generators_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return GeneratorExp(_elt, _generators, _lineno, _col_offset)

State.ast_type('GeneratorExp', 'expr', ['elt', 'generators'])


class Yield(expr):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Yield(self)

    def mutate_over(self, visitor):
        if self.value:
            self.value = self.value.mutate_over(visitor)
        return visitor.visit_Yield(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Yield)
        w_value = self.value.to_object(space) if self.value is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = expr.from_object(space, w_value)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Yield(_value, _lineno, _col_offset)

State.ast_type('Yield', 'expr', ['value'])


class Compare(expr):

    def __init__(self, left, ops, comparators, lineno, col_offset):
        self.left = left
        self.ops = ops
        self.comparators = comparators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Compare(self)

    def mutate_over(self, visitor):
        self.left = self.left.mutate_over(visitor)
        if self.comparators:
            visitor._mutate_sequence(self.comparators)
        return visitor.visit_Compare(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Compare)
        w_left = self.left.to_object(space)  # expr
        space.setattr(w_node, space.wrap('left'), w_left)
        if self.ops is None:
            ops_w = []
        else:
            ops_w = [cmpop_to_class[node - 1]().to_object(space) for node in self.ops] # cmpop
        w_ops = space.newlist(ops_w)
        space.setattr(w_node, space.wrap('ops'), w_ops)
        if self.comparators is None:
            comparators_w = []
        else:
            comparators_w = [node.to_object(space) for node in self.comparators] # expr
        w_comparators = space.newlist(comparators_w)
        space.setattr(w_node, space.wrap('comparators'), w_comparators)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_left = get_field(space, w_node, 'left', False)
        w_ops = get_field(space, w_node, 'ops', False)
        w_comparators = get_field(space, w_node, 'comparators', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _left = expr.from_object(space, w_left)
        ops_w = space.unpackiterable(w_ops)
        _ops = [cmpop.from_object(space, w_item) for w_item in ops_w]
        comparators_w = space.unpackiterable(w_comparators)
        _comparators = [expr.from_object(space, w_item) for w_item in comparators_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Compare(_left, _ops, _comparators, _lineno, _col_offset)

State.ast_type('Compare', 'expr', ['left', 'ops', 'comparators'])


class Call(expr):

    def __init__(self, func, args, keywords, starargs, kwargs, lineno, col_offset):
        self.func = func
        self.args = args
        self.keywords = keywords
        self.starargs = starargs
        self.kwargs = kwargs
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Call(self)

    def mutate_over(self, visitor):
        self.func = self.func.mutate_over(visitor)
        if self.args:
            visitor._mutate_sequence(self.args)
        if self.keywords:
            visitor._mutate_sequence(self.keywords)
        if self.starargs:
            self.starargs = self.starargs.mutate_over(visitor)
        if self.kwargs:
            self.kwargs = self.kwargs.mutate_over(visitor)
        return visitor.visit_Call(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Call)
        w_func = self.func.to_object(space)  # expr
        space.setattr(w_node, space.wrap('func'), w_func)
        if self.args is None:
            args_w = []
        else:
            args_w = [node.to_object(space) for node in self.args] # expr
        w_args = space.newlist(args_w)
        space.setattr(w_node, space.wrap('args'), w_args)
        if self.keywords is None:
            keywords_w = []
        else:
            keywords_w = [node.to_object(space) for node in self.keywords] # keyword
        w_keywords = space.newlist(keywords_w)
        space.setattr(w_node, space.wrap('keywords'), w_keywords)
        w_starargs = self.starargs.to_object(space) if self.starargs is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('starargs'), w_starargs)
        w_kwargs = self.kwargs.to_object(space) if self.kwargs is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('kwargs'), w_kwargs)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_func = get_field(space, w_node, 'func', False)
        w_args = get_field(space, w_node, 'args', False)
        w_keywords = get_field(space, w_node, 'keywords', False)
        w_starargs = get_field(space, w_node, 'starargs', True)
        w_kwargs = get_field(space, w_node, 'kwargs', True)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _func = expr.from_object(space, w_func)
        args_w = space.unpackiterable(w_args)
        _args = [expr.from_object(space, w_item) for w_item in args_w]
        keywords_w = space.unpackiterable(w_keywords)
        _keywords = [keyword.from_object(space, w_item) for w_item in keywords_w]
        _starargs = expr.from_object(space, w_starargs)
        _kwargs = expr.from_object(space, w_kwargs)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Call(_func, _args, _keywords, _starargs, _kwargs, _lineno, _col_offset)

State.ast_type('Call', 'expr', ['func', 'args', 'keywords', 'starargs', 'kwargs'])


class Num(expr):

    def __init__(self, n, lineno, col_offset):
        self.n = n
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Num(self)

    def mutate_over(self, visitor):
        return visitor.visit_Num(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            self.missing_field(space, ['lineno', 'col_offset', 'n'], 'Num')
        else:
            pass
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_Repr)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = expr.from_object(space, w_value)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Repr(_value, _lineno, _col_offset)

State.ast_type('Repr', 'expr', ['value'])
>>>>>>> theirs


class Str(expr):

    def __init__(self, s, lineno, col_offset):
        self.s = s
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Str(self)

    def mutate_over(self, visitor):
        return visitor.visit_Str(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            self.missing_field(space, ['lineno', 'col_offset', 's'], 'Str')
        else:
            pass
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_Num)
        w_n = self.n  # object
        space.setattr(w_node, space.wrap('n'), w_n)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_n = get_field(space, w_node, 'n', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _n = w_n
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Num(_n, _lineno, _col_offset)

State.ast_type('Num', 'expr', ['n'])
>>>>>>> theirs


class Bytes(expr):

    def __init__(self, s, lineno, col_offset):
        self.s = s
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Bytes(self)

    def mutate_over(self, visitor):
        return visitor.visit_Bytes(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            self.missing_field(space, ['lineno', 'col_offset', 's'], 'Bytes')
        else:
            pass


class Ellipsis(expr):

    def __init__(self, lineno, col_offset):
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 3

    def walkabout(self, visitor):
        visitor.visit_Ellipsis(self)

    def mutate_over(self, visitor):
        return visitor.visit_Ellipsis(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 3:
            self.missing_field(space, ['lineno', 'col_offset'], 'Ellipsis')
        else:
            pass
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_Str)
        w_s = self.s  # string
        space.setattr(w_node, space.wrap('s'), w_s)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_s = get_field(space, w_node, 's', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _s = check_string(space, w_s)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Str(_s, _lineno, _col_offset)

State.ast_type('Str', 'expr', ['s'])
>>>>>>> theirs


class Attribute(expr):

    def __init__(self, value, attr, ctx, lineno, col_offset):
        self.value = value
        self.attr = attr
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Attribute(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Attribute(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Attribute)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_attr = space.wrap(self.attr)  # identifier
        space.setattr(w_node, space.wrap('attr'), w_attr)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', False)
        w_attr = get_field(space, w_node, 'attr', False)
        w_ctx = get_field(space, w_node, 'ctx', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = expr.from_object(space, w_value)
        _attr = space.realstr_w(w_attr)
        _ctx = expr_context.from_object(space, w_ctx)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Attribute(_value, _attr, _ctx, _lineno, _col_offset)

State.ast_type('Attribute', 'expr', ['value', 'attr', 'ctx'])


class Subscript(expr):

    def __init__(self, value, slice, ctx, lineno, col_offset):
        self.value = value
        self.slice = slice
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Subscript(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        self.slice = self.slice.mutate_over(visitor)
        return visitor.visit_Subscript(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Subscript)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_slice = self.slice.to_object(space)  # slice
        space.setattr(w_node, space.wrap('slice'), w_slice)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', False)
        w_slice = get_field(space, w_node, 'slice', False)
        w_ctx = get_field(space, w_node, 'ctx', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = expr.from_object(space, w_value)
        _slice = slice.from_object(space, w_slice)
        _ctx = expr_context.from_object(space, w_ctx)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Subscript(_value, _slice, _ctx, _lineno, _col_offset)

State.ast_type('Subscript', 'expr', ['value', 'slice', 'ctx'])


class Starred(expr):

    def __init__(self, value, ctx, lineno, col_offset):
        self.value = value
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Starred(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Starred(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            self.missing_field(space, ['lineno', 'col_offset', 'value', 'ctx'], 'Starred')
        else:
            pass
        self.value.sync_app_attrs(space)


class Name(expr):

    def __init__(self, id, ctx, lineno, col_offset):
        self.id = id
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Name(self)

    def mutate_over(self, visitor):
        return visitor.visit_Name(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Name)
        w_id = space.wrap(self.id)  # identifier
        space.setattr(w_node, space.wrap('id'), w_id)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_id = get_field(space, w_node, 'id', False)
        w_ctx = get_field(space, w_node, 'ctx', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _id = space.realstr_w(w_id)
        _ctx = expr_context.from_object(space, w_ctx)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Name(_id, _ctx, _lineno, _col_offset)

State.ast_type('Name', 'expr', ['id', 'ctx'])


class List(expr):

    def __init__(self, elts, ctx, lineno, col_offset):
        self.elts = elts
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_List(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_List(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_List)
        if self.elts is None:
            elts_w = []
        else:
            elts_w = [node.to_object(space) for node in self.elts] # expr
        w_elts = space.newlist(elts_w)
        space.setattr(w_node, space.wrap('elts'), w_elts)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_elts = get_field(space, w_node, 'elts', False)
        w_ctx = get_field(space, w_node, 'ctx', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        elts_w = space.unpackiterable(w_elts)
        _elts = [expr.from_object(space, w_item) for w_item in elts_w]
        _ctx = expr_context.from_object(space, w_ctx)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return List(_elts, _ctx, _lineno, _col_offset)

State.ast_type('List', 'expr', ['elts', 'ctx'])


class Tuple(expr):

    def __init__(self, elts, ctx, lineno, col_offset):
        self.elts = elts
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Tuple(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_Tuple(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Tuple)
        if self.elts is None:
            elts_w = []
        else:
            elts_w = [node.to_object(space) for node in self.elts] # expr
        w_elts = space.newlist(elts_w)
        space.setattr(w_node, space.wrap('elts'), w_elts)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_elts = get_field(space, w_node, 'elts', False)
        w_ctx = get_field(space, w_node, 'ctx', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        elts_w = space.unpackiterable(w_elts)
        _elts = [expr.from_object(space, w_item) for w_item in elts_w]
        _ctx = expr_context.from_object(space, w_ctx)
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Tuple(_elts, _ctx, _lineno, _col_offset)

State.ast_type('Tuple', 'expr', ['elts', 'ctx'])


class Const(expr):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Const(self)

    def mutate_over(self, visitor):
        return visitor.visit_Const(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Const)
        w_value = self.value  # object
        space.setattr(w_node, space.wrap('value'), w_value)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _value = w_value
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return Const(_value, _lineno, _col_offset)

State.ast_type('Const', 'expr', ['value'])


class expr_context(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.isinstance_w(w_node, get(space).w_Load):
            return 1
        if space.isinstance_w(w_node, get(space).w_Store):
            return 2
        if space.isinstance_w(w_node, get(space).w_Del):
            return 3
        if space.isinstance_w(w_node, get(space).w_AugLoad):
            return 4
        if space.isinstance_w(w_node, get(space).w_AugStore):
            return 5
        if space.isinstance_w(w_node, get(space).w_Param):
            return 6
        raise oefmt(space.w_TypeError,
                "Expected expr_context node, got %T", w_node)
State.ast_type('expr_context', 'AST', None)

class _Load(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Load)
State.ast_type('Load', 'expr_context', None)

class _Store(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Store)
State.ast_type('Store', 'expr_context', None)

class _Del(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Del)
State.ast_type('Del', 'expr_context', None)

class _AugLoad(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_AugLoad)
State.ast_type('AugLoad', 'expr_context', None)

class _AugStore(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_AugStore)
State.ast_type('AugStore', 'expr_context', None)

class _Param(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Param)
State.ast_type('Param', 'expr_context', None)

Load = 1
Store = 2
Del = 3
AugLoad = 4
AugStore = 5
Param = 6

expr_context_to_class = [
    _Load,
    _Store,
    _Del,
    _AugLoad,
    _AugStore,
    _Param,
]

class slice(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.is_w(w_node, space.w_None):
            return None
        if space.isinstance_w(w_node, get(space).w_Ellipsis):
            return Ellipsis.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Slice):
            return Slice.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_ExtSlice):
            return ExtSlice.from_object(space, w_node)
        if space.isinstance_w(w_node, get(space).w_Index):
            return Index.from_object(space, w_node)
        raise oefmt(space.w_TypeError,
                "Expected slice node, got %T", w_node)
State.ast_type('slice', 'AST', None, [])

<<<<<<< mine
=======
class Ellipsis(slice):


    def walkabout(self, visitor):
        visitor.visit_Ellipsis(self)

    def mutate_over(self, visitor):
        return visitor.visit_Ellipsis(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Ellipsis)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        return Ellipsis()

State.ast_type('Ellipsis', 'slice', [])


>>>>>>> theirs
class Slice(slice):

    def __init__(self, lower, upper, step):
        self.lower = lower
        self.upper = upper
        self.step = step

    def walkabout(self, visitor):
        visitor.visit_Slice(self)

    def mutate_over(self, visitor):
        if self.lower:
            self.lower = self.lower.mutate_over(visitor)
        if self.upper:
            self.upper = self.upper.mutate_over(visitor)
        if self.step:
            self.step = self.step.mutate_over(visitor)
        return visitor.visit_Slice(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Slice)
        w_lower = self.lower.to_object(space) if self.lower is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('lower'), w_lower)
        w_upper = self.upper.to_object(space) if self.upper is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('upper'), w_upper)
        w_step = self.step.to_object(space) if self.step is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('step'), w_step)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_lower = get_field(space, w_node, 'lower', True)
        w_upper = get_field(space, w_node, 'upper', True)
        w_step = get_field(space, w_node, 'step', True)
        _lower = expr.from_object(space, w_lower)
        _upper = expr.from_object(space, w_upper)
        _step = expr.from_object(space, w_step)
        return Slice(_lower, _upper, _step)

State.ast_type('Slice', 'slice', ['lower', 'upper', 'step'])


class ExtSlice(slice):

    def __init__(self, dims):
        self.dims = dims

    def walkabout(self, visitor):
        visitor.visit_ExtSlice(self)

    def mutate_over(self, visitor):
        if self.dims:
            visitor._mutate_sequence(self.dims)
        return visitor.visit_ExtSlice(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ExtSlice)
        if self.dims is None:
            dims_w = []
        else:
            dims_w = [node.to_object(space) for node in self.dims] # slice
        w_dims = space.newlist(dims_w)
        space.setattr(w_node, space.wrap('dims'), w_dims)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_dims = get_field(space, w_node, 'dims', False)
        dims_w = space.unpackiterable(w_dims)
        _dims = [slice.from_object(space, w_item) for w_item in dims_w]
        return ExtSlice(_dims)

State.ast_type('ExtSlice', 'slice', ['dims'])


class Index(slice):

    def __init__(self, value):
        self.value = value

    def walkabout(self, visitor):
        visitor.visit_Index(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Index(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Index)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_value = get_field(space, w_node, 'value', False)
        _value = expr.from_object(space, w_value)
        return Index(_value)

State.ast_type('Index', 'slice', ['value'])


class boolop(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.isinstance_w(w_node, get(space).w_And):
            return 1
        if space.isinstance_w(w_node, get(space).w_Or):
            return 2
        raise oefmt(space.w_TypeError,
                "Expected boolop node, got %T", w_node)
State.ast_type('boolop', 'AST', None)

class _And(boolop):
    def to_object(self, space):
        return space.call_function(get(space).w_And)
State.ast_type('And', 'boolop', None)

class _Or(boolop):
    def to_object(self, space):
        return space.call_function(get(space).w_Or)
State.ast_type('Or', 'boolop', None)

And = 1
Or = 2

boolop_to_class = [
    _And,
    _Or,
]

class operator(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.isinstance_w(w_node, get(space).w_Add):
            return 1
        if space.isinstance_w(w_node, get(space).w_Sub):
            return 2
        if space.isinstance_w(w_node, get(space).w_Mult):
            return 3
        if space.isinstance_w(w_node, get(space).w_Div):
            return 4
        if space.isinstance_w(w_node, get(space).w_Mod):
            return 5
        if space.isinstance_w(w_node, get(space).w_Pow):
            return 6
        if space.isinstance_w(w_node, get(space).w_LShift):
            return 7
        if space.isinstance_w(w_node, get(space).w_RShift):
            return 8
        if space.isinstance_w(w_node, get(space).w_BitOr):
            return 9
        if space.isinstance_w(w_node, get(space).w_BitXor):
            return 10
        if space.isinstance_w(w_node, get(space).w_BitAnd):
            return 11
        if space.isinstance_w(w_node, get(space).w_FloorDiv):
            return 12
        raise oefmt(space.w_TypeError,
                "Expected operator node, got %T", w_node)
State.ast_type('operator', 'AST', None)

class _Add(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Add)
State.ast_type('Add', 'operator', None)

class _Sub(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Sub)
State.ast_type('Sub', 'operator', None)

class _Mult(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Mult)
State.ast_type('Mult', 'operator', None)

class _Div(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Div)
State.ast_type('Div', 'operator', None)

class _Mod(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Mod)
State.ast_type('Mod', 'operator', None)

class _Pow(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Pow)
State.ast_type('Pow', 'operator', None)

class _LShift(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_LShift)
State.ast_type('LShift', 'operator', None)

class _RShift(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_RShift)
State.ast_type('RShift', 'operator', None)

class _BitOr(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_BitOr)
State.ast_type('BitOr', 'operator', None)

class _BitXor(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_BitXor)
State.ast_type('BitXor', 'operator', None)

class _BitAnd(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_BitAnd)
State.ast_type('BitAnd', 'operator', None)

class _FloorDiv(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_FloorDiv)
State.ast_type('FloorDiv', 'operator', None)

Add = 1
Sub = 2
Mult = 3
Div = 4
Mod = 5
Pow = 6
LShift = 7
RShift = 8
BitOr = 9
BitXor = 10
BitAnd = 11
FloorDiv = 12

operator_to_class = [
    _Add,
    _Sub,
    _Mult,
    _Div,
    _Mod,
    _Pow,
    _LShift,
    _RShift,
    _BitOr,
    _BitXor,
    _BitAnd,
    _FloorDiv,
]

class unaryop(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.isinstance_w(w_node, get(space).w_Invert):
            return 1
        if space.isinstance_w(w_node, get(space).w_Not):
            return 2
        if space.isinstance_w(w_node, get(space).w_UAdd):
            return 3
        if space.isinstance_w(w_node, get(space).w_USub):
            return 4
        raise oefmt(space.w_TypeError,
                "Expected unaryop node, got %T", w_node)
State.ast_type('unaryop', 'AST', None)

class _Invert(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_Invert)
State.ast_type('Invert', 'unaryop', None)

class _Not(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_Not)
State.ast_type('Not', 'unaryop', None)

class _UAdd(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_UAdd)
State.ast_type('UAdd', 'unaryop', None)

class _USub(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_USub)
State.ast_type('USub', 'unaryop', None)

Invert = 1
Not = 2
UAdd = 3
USub = 4

unaryop_to_class = [
    _Invert,
    _Not,
    _UAdd,
    _USub,
]

class cmpop(AST):
    @staticmethod
    def from_object(space, w_node):
        if space.isinstance_w(w_node, get(space).w_Eq):
            return 1
        if space.isinstance_w(w_node, get(space).w_NotEq):
            return 2
        if space.isinstance_w(w_node, get(space).w_Lt):
            return 3
        if space.isinstance_w(w_node, get(space).w_LtE):
            return 4
        if space.isinstance_w(w_node, get(space).w_Gt):
            return 5
        if space.isinstance_w(w_node, get(space).w_GtE):
            return 6
        if space.isinstance_w(w_node, get(space).w_Is):
            return 7
        if space.isinstance_w(w_node, get(space).w_IsNot):
            return 8
        if space.isinstance_w(w_node, get(space).w_In):
            return 9
        if space.isinstance_w(w_node, get(space).w_NotIn):
            return 10
        raise oefmt(space.w_TypeError,
                "Expected cmpop node, got %T", w_node)
State.ast_type('cmpop', 'AST', None)

class _Eq(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Eq)
State.ast_type('Eq', 'cmpop', None)

class _NotEq(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_NotEq)
State.ast_type('NotEq', 'cmpop', None)

class _Lt(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Lt)
State.ast_type('Lt', 'cmpop', None)

class _LtE(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_LtE)
State.ast_type('LtE', 'cmpop', None)

class _Gt(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Gt)
State.ast_type('Gt', 'cmpop', None)

class _GtE(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_GtE)
State.ast_type('GtE', 'cmpop', None)

class _Is(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Is)
State.ast_type('Is', 'cmpop', None)

class _IsNot(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_IsNot)
State.ast_type('IsNot', 'cmpop', None)

class _In(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_In)
State.ast_type('In', 'cmpop', None)

class _NotIn(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_NotIn)
State.ast_type('NotIn', 'cmpop', None)

Eq = 1
NotEq = 2
Lt = 3
LtE = 4
Gt = 5
GtE = 6
Is = 7
IsNot = 8
In = 9
NotIn = 10

cmpop_to_class = [
    _Eq,
    _NotEq,
    _Lt,
    _LtE,
    _Gt,
    _GtE,
    _Is,
    _IsNot,
    _In,
    _NotIn,
]

class comprehension(AST):

    def __init__(self, target, iter, ifs):
        self.target = target
        self.iter = iter
        self.ifs = ifs

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.iter = self.iter.mutate_over(visitor)
        if self.ifs:
            visitor._mutate_sequence(self.ifs)
        return visitor.visit_comprehension(self)

    def walkabout(self, visitor):
        visitor.visit_comprehension(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_comprehension)
        w_target = self.target.to_object(space)  # expr
        space.setattr(w_node, space.wrap('target'), w_target)
        w_iter = self.iter.to_object(space)  # expr
        space.setattr(w_node, space.wrap('iter'), w_iter)
        if self.ifs is None:
            ifs_w = []
        else:
            ifs_w = [node.to_object(space) for node in self.ifs] # expr
        w_ifs = space.newlist(ifs_w)
        space.setattr(w_node, space.wrap('ifs'), w_ifs)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_target = get_field(space, w_node, 'target', False)
        w_iter = get_field(space, w_node, 'iter', False)
        w_ifs = get_field(space, w_node, 'ifs', False)
        _target = expr.from_object(space, w_target)
        _iter = expr.from_object(space, w_iter)
        ifs_w = space.unpackiterable(w_ifs)
        _ifs = [expr.from_object(space, w_item) for w_item in ifs_w]
        return comprehension(_target, _iter, _ifs)

State.ast_type('comprehension', 'AST', ['target', 'iter', 'ifs'])

class excepthandler(AST):

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset

    @staticmethod
    def from_object(space, w_node):
        if space.is_w(w_node, space.w_None):
            return None
        if space.isinstance_w(w_node, get(space).w_ExceptHandler):
            return ExceptHandler.from_object(space, w_node)
        raise oefmt(space.w_TypeError,
                "Expected excepthandler node, got %T", w_node)
State.ast_type('excepthandler', 'AST', None, ['lineno', 'col_offset'])

class ExceptHandler(excepthandler):

    def __init__(self, type, name, body, lineno, col_offset):
        self.type = type
        self.name = name
        self.body = body
        excepthandler.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ExceptHandler(self)

    def mutate_over(self, visitor):
        if self.type:
            self.type = self.type.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_ExceptHandler(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~12) ^ 19:
            self.missing_field(space, ['lineno', 'col_offset', None, None, 'body'], 'ExceptHandler')
        else:
            if not self.initialization_state & 4:
                self.type = None
            if not self.initialization_state & 8:
                self.name = None
        if self.type:
            self.type.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_ExceptHandler)
        w_type = self.type.to_object(space) if self.type is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('type'), w_type)
        w_name = self.name.to_object(space) if self.name is not None else space.w_None  # expr
        space.setattr(w_node, space.wrap('name'), w_name)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        w_lineno = space.wrap(self.lineno)  # int
        space.setattr(w_node, space.wrap('lineno'), w_lineno)
        w_col_offset = space.wrap(self.col_offset)  # int
        space.setattr(w_node, space.wrap('col_offset'), w_col_offset)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_type = get_field(space, w_node, 'type', True)
        w_name = get_field(space, w_node, 'name', True)
        w_body = get_field(space, w_node, 'body', False)
        w_lineno = get_field(space, w_node, 'lineno', False)
        w_col_offset = get_field(space, w_node, 'col_offset', False)
        _type = expr.from_object(space, w_type)
        _name = expr.from_object(space, w_name)
        body_w = space.unpackiterable(w_body)
        _body = [stmt.from_object(space, w_item) for w_item in body_w]
        _lineno = space.int_w(w_lineno)
        _col_offset = space.int_w(w_col_offset)
        return ExceptHandler(_type, _name, _body, _lineno, _col_offset)

State.ast_type('ExceptHandler', 'excepthandler', ['type', 'name', 'body'])
>>>>>>> theirs


class arguments(AST):

    def __init__(self, args, vararg, varargannotation, kwonlyargs, kwarg, kwargannotation, defaults, kw_defaults):
        self.args = args
        self.vararg = vararg
        self.varargannotation = varargannotation
        self.kwonlyargs = kwonlyargs
        self.w_kwonlyargs = None
        self.kwarg = kwarg
        self.kwargannotation = kwargannotation
        self.defaults = defaults
<<<<<<< mine
        self.w_defaults = None
        self.kw_defaults = kw_defaults
        self.w_kw_defaults = None
        self.initialization_state = 255
=======
>>>>>>> theirs

    def mutate_over(self, visitor):
        if self.args:
            visitor._mutate_sequence(self.args)
        if self.varargannotation:
            self.varargannotation = self.varargannotation.mutate_over(visitor)
        if self.kwonlyargs:
            visitor._mutate_sequence(self.kwonlyargs)
        if self.kwargannotation:
            self.kwargannotation = self.kwargannotation.mutate_over(visitor)
        if self.defaults:
            visitor._mutate_sequence(self.defaults)
        if self.kw_defaults:
            visitor._mutate_sequence(self.kw_defaults)
        return visitor.visit_arguments(self)

    def walkabout(self, visitor):
        visitor.visit_arguments(self)

<<<<<<< mine
    def sync_app_attrs(self, space):
        if (self.initialization_state & ~54) ^ 201:
            self.missing_field(space, ['args', None, None, 'kwonlyargs', None, None, 'defaults', 'kw_defaults'], 'arguments')
        else:
            if not self.initialization_state & 2:
                self.vararg = None
            if not self.initialization_state & 4:
                self.varargannotation = None
            if not self.initialization_state & 16:
                self.kwarg = None
            if not self.initialization_state & 32:
                self.kwargannotation = None
        w_list = self.w_args
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.args = [space.interp_w(arg, w_obj) for w_obj in list_w]
            else:
                self.args = None
        if self.args is not None:
            for node in self.args:
                node.sync_app_attrs(space)
        if self.varargannotation:
            self.varargannotation.sync_app_attrs(space)
        w_list = self.w_kwonlyargs
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.kwonlyargs = [space.interp_w(arg, w_obj) for w_obj in list_w]
            else:
                self.kwonlyargs = None
        if self.kwonlyargs is not None:
            for node in self.kwonlyargs:
                node.sync_app_attrs(space)
        if self.kwargannotation:
            self.kwargannotation.sync_app_attrs(space)
        w_list = self.w_defaults
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.defaults = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.defaults = None
        if self.defaults is not None:
            for node in self.defaults:
                node.sync_app_attrs(space)
        w_list = self.w_kw_defaults
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.kw_defaults = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.kw_defaults = None
        if self.kw_defaults is not None:
            for node in self.kw_defaults:
                if node:
                    node.sync_app_attrs(space)

class arg(AST):

    def __init__(self, arg, annotation):
        self.arg = arg
        self.annotation = annotation
        self.initialization_state = 3

    def mutate_over(self, visitor):
        if self.annotation:
            self.annotation = self.annotation.mutate_over(visitor)
        return visitor.visit_arg(self)

    def walkabout(self, visitor):
        visitor.visit_arg(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~2) ^ 1:
            self.missing_field(space, ['arg', None], 'arg')
        else:
            if not self.initialization_state & 2:
                self.annotation = None
        if self.annotation:
            self.annotation.sync_app_attrs(space)
=======
    def to_object(self, space):
        w_node = space.call_function(get(space).w_arguments)
        if self.args is None:
            args_w = []
        else:
            args_w = [node.to_object(space) for node in self.args] # expr
        w_args = space.newlist(args_w)
        space.setattr(w_node, space.wrap('args'), w_args)
        w_vararg = space.wrap(self.vararg)  # identifier
        space.setattr(w_node, space.wrap('vararg'), w_vararg)
        w_kwarg = space.wrap(self.kwarg)  # identifier
        space.setattr(w_node, space.wrap('kwarg'), w_kwarg)
        if self.defaults is None:
            defaults_w = []
        else:
            defaults_w = [node.to_object(space) for node in self.defaults] # expr
        w_defaults = space.newlist(defaults_w)
        space.setattr(w_node, space.wrap('defaults'), w_defaults)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_args = get_field(space, w_node, 'args', False)
        w_vararg = get_field(space, w_node, 'vararg', True)
        w_kwarg = get_field(space, w_node, 'kwarg', True)
        w_defaults = get_field(space, w_node, 'defaults', False)
        args_w = space.unpackiterable(w_args)
        _args = [expr.from_object(space, w_item) for w_item in args_w]
        _vararg = space.str_or_None_w(w_vararg)
        _kwarg = space.str_or_None_w(w_kwarg)
        defaults_w = space.unpackiterable(w_defaults)
        _defaults = [expr.from_object(space, w_item) for w_item in defaults_w]
        return arguments(_args, _vararg, _kwarg, _defaults)

State.ast_type('arguments', 'AST', ['args', 'vararg', 'kwarg', 'defaults'])
>>>>>>> theirs

class keyword(AST):

    def __init__(self, arg, value):
        self.arg = arg
        self.value = value

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_keyword(self)

    def walkabout(self, visitor):
        visitor.visit_keyword(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_keyword)
        w_arg = space.wrap(self.arg)  # identifier
        space.setattr(w_node, space.wrap('arg'), w_arg)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_arg = get_field(space, w_node, 'arg', False)
        w_value = get_field(space, w_node, 'value', False)
        _arg = space.realstr_w(w_arg)
        _value = expr.from_object(space, w_value)
        return keyword(_arg, _value)

State.ast_type('keyword', 'AST', ['arg', 'value'])

class alias(AST):

    def __init__(self, name, asname):
        self.name = name
        self.asname = asname

    def mutate_over(self, visitor):
        return visitor.visit_alias(self)

    def walkabout(self, visitor):
        visitor.visit_alias(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_alias)
        w_name = space.wrap(self.name)  # identifier
        space.setattr(w_node, space.wrap('name'), w_name)
        w_asname = space.wrap(self.asname)  # identifier
        space.setattr(w_node, space.wrap('asname'), w_asname)
        return w_node

    @staticmethod
    def from_object(space, w_node):
        w_name = get_field(space, w_node, 'name', False)
        w_asname = get_field(space, w_node, 'asname', True)
        _name = space.realstr_w(w_name)
        _asname = space.str_or_None_w(w_asname)
        return alias(_name, _asname)

State.ast_type('alias', 'AST', ['name', 'asname'])

class ASTVisitor(object):

    def visit_sequence(self, seq):
        if seq is not None:
            for node in seq:
                node.walkabout(self)

    def visit_kwonlydefaults(self, seq):
        if seq is not None:
            for node in seq:
                if node:
                    node.walkabout(self)

    def default_visitor(self, node):
        raise NodeVisitorNotImplemented

    def _mutate_sequence(self, seq):
        for i in range(len(seq)):
            if seq[i] is not None:
                seq[i] = seq[i].mutate_over(self)

    def visit_Module(self, node):
        return self.default_visitor(node)
    def visit_Interactive(self, node):
        return self.default_visitor(node)
    def visit_Expression(self, node):
        return self.default_visitor(node)
    def visit_Suite(self, node):
        return self.default_visitor(node)
    def visit_FunctionDef(self, node):
        return self.default_visitor(node)
    def visit_ClassDef(self, node):
        return self.default_visitor(node)
    def visit_Return(self, node):
        return self.default_visitor(node)
    def visit_Delete(self, node):
        return self.default_visitor(node)
    def visit_Assign(self, node):
        return self.default_visitor(node)
    def visit_AugAssign(self, node):
        return self.default_visitor(node)
    def visit_For(self, node):
        return self.default_visitor(node)
    def visit_While(self, node):
        return self.default_visitor(node)
    def visit_If(self, node):
        return self.default_visitor(node)
    def visit_With(self, node):
        return self.default_visitor(node)
    def visit_Raise(self, node):
        return self.default_visitor(node)
    def visit_TryExcept(self, node):
        return self.default_visitor(node)
    def visit_TryFinally(self, node):
        return self.default_visitor(node)
    def visit_Assert(self, node):
        return self.default_visitor(node)
    def visit_Import(self, node):
        return self.default_visitor(node)
    def visit_ImportFrom(self, node):
        return self.default_visitor(node)
    def visit_Global(self, node):
        return self.default_visitor(node)
    def visit_Nonlocal(self, node):
        return self.default_visitor(node)
    def visit_Expr(self, node):
        return self.default_visitor(node)
    def visit_Pass(self, node):
        return self.default_visitor(node)
    def visit_Break(self, node):
        return self.default_visitor(node)
    def visit_Continue(self, node):
        return self.default_visitor(node)
    def visit_BoolOp(self, node):
        return self.default_visitor(node)
    def visit_BinOp(self, node):
        return self.default_visitor(node)
    def visit_UnaryOp(self, node):
        return self.default_visitor(node)
    def visit_Lambda(self, node):
        return self.default_visitor(node)
    def visit_IfExp(self, node):
        return self.default_visitor(node)
    def visit_Dict(self, node):
        return self.default_visitor(node)
    def visit_Set(self, node):
        return self.default_visitor(node)
    def visit_ListComp(self, node):
        return self.default_visitor(node)
    def visit_SetComp(self, node):
        return self.default_visitor(node)
    def visit_DictComp(self, node):
        return self.default_visitor(node)
    def visit_GeneratorExp(self, node):
        return self.default_visitor(node)
    def visit_Yield(self, node):
        return self.default_visitor(node)
    def visit_Compare(self, node):
        return self.default_visitor(node)
    def visit_Call(self, node):
        return self.default_visitor(node)
    def visit_Num(self, node):
        return self.default_visitor(node)
    def visit_Str(self, node):
        return self.default_visitor(node)
    def visit_Bytes(self, node):
        return self.default_visitor(node)
    def visit_Ellipsis(self, node):
        return self.default_visitor(node)
    def visit_Attribute(self, node):
        return self.default_visitor(node)
    def visit_Subscript(self, node):
        return self.default_visitor(node)
    def visit_Starred(self, node):
        return self.default_visitor(node)
    def visit_Name(self, node):
        return self.default_visitor(node)
    def visit_List(self, node):
        return self.default_visitor(node)
    def visit_Tuple(self, node):
        return self.default_visitor(node)
    def visit_Const(self, node):
        return self.default_visitor(node)
    def visit_Slice(self, node):
        return self.default_visitor(node)
    def visit_ExtSlice(self, node):
        return self.default_visitor(node)
    def visit_Index(self, node):
        return self.default_visitor(node)
    def visit_comprehension(self, node):
        return self.default_visitor(node)
    def visit_ExceptHandler(self, node):
        return self.default_visitor(node)
    def visit_arguments(self, node):
        return self.default_visitor(node)
    def visit_arg(self, node):
        return self.default_visitor(node)
    def visit_keyword(self, node):
        return self.default_visitor(node)
    def visit_alias(self, node):
        return self.default_visitor(node)

class GenericASTVisitor(ASTVisitor):

    def visit_Module(self, node):
        self.visit_sequence(node.body)

    def visit_Interactive(self, node):
        self.visit_sequence(node.body)

    def visit_Expression(self, node):
        node.body.walkabout(self)

    def visit_Suite(self, node):
        self.visit_sequence(node.body)

    def visit_FunctionDef(self, node):
        node.args.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.decorator_list)
        if node.returns:
            node.returns.walkabout(self)

    def visit_ClassDef(self, node):
        self.visit_sequence(node.bases)
        self.visit_sequence(node.keywords)
        if node.starargs:
            node.starargs.walkabout(self)
        if node.kwargs:
            node.kwargs.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.decorator_list)

    def visit_Return(self, node):
        if node.value:
            node.value.walkabout(self)

    def visit_Delete(self, node):
        self.visit_sequence(node.targets)

    def visit_Assign(self, node):
        self.visit_sequence(node.targets)
        node.value.walkabout(self)

    def visit_AugAssign(self, node):
        node.target.walkabout(self)
        node.value.walkabout(self)

    def visit_For(self, node):
        node.target.walkabout(self)
        node.iter.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.orelse)

    def visit_While(self, node):
        node.test.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.orelse)

    def visit_If(self, node):
        node.test.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.orelse)

    def visit_With(self, node):
        node.context_expr.walkabout(self)
        if node.optional_vars:
            node.optional_vars.walkabout(self)
        self.visit_sequence(node.body)

    def visit_Raise(self, node):
        if node.exc:
            node.exc.walkabout(self)
        if node.cause:
            node.cause.walkabout(self)

    def visit_TryExcept(self, node):
        self.visit_sequence(node.body)
        self.visit_sequence(node.handlers)
        self.visit_sequence(node.orelse)

    def visit_TryFinally(self, node):
        self.visit_sequence(node.body)
        self.visit_sequence(node.finalbody)

    def visit_Assert(self, node):
        node.test.walkabout(self)
        if node.msg:
            node.msg.walkabout(self)

    def visit_Import(self, node):
        self.visit_sequence(node.names)

    def visit_ImportFrom(self, node):
        self.visit_sequence(node.names)

    def visit_Global(self, node):
        pass

    def visit_Nonlocal(self, node):
        pass

    def visit_Expr(self, node):
        node.value.walkabout(self)

    def visit_Pass(self, node):
        pass

    def visit_Break(self, node):
        pass

    def visit_Continue(self, node):
        pass

    def visit_BoolOp(self, node):
        self.visit_sequence(node.values)

    def visit_BinOp(self, node):
        node.left.walkabout(self)
        node.right.walkabout(self)

    def visit_UnaryOp(self, node):
        node.operand.walkabout(self)

    def visit_Lambda(self, node):
        node.args.walkabout(self)
        node.body.walkabout(self)

    def visit_IfExp(self, node):
        node.test.walkabout(self)
        node.body.walkabout(self)
        node.orelse.walkabout(self)

    def visit_Dict(self, node):
        self.visit_sequence(node.keys)
        self.visit_sequence(node.values)

    def visit_Set(self, node):
        self.visit_sequence(node.elts)

    def visit_ListComp(self, node):
        node.elt.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_SetComp(self, node):
        node.elt.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_DictComp(self, node):
        node.key.walkabout(self)
        node.value.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_GeneratorExp(self, node):
        node.elt.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_Yield(self, node):
        if node.value:
            node.value.walkabout(self)

    def visit_Compare(self, node):
        node.left.walkabout(self)
        self.visit_sequence(node.comparators)

    def visit_Call(self, node):
        node.func.walkabout(self)
        self.visit_sequence(node.args)
        self.visit_sequence(node.keywords)
        if node.starargs:
            node.starargs.walkabout(self)
        if node.kwargs:
            node.kwargs.walkabout(self)

    def visit_Num(self, node):
        pass

    def visit_Str(self, node):
        pass

    def visit_Bytes(self, node):
        pass

    def visit_Ellipsis(self, node):
        pass

    def visit_Attribute(self, node):
        node.value.walkabout(self)

    def visit_Subscript(self, node):
        node.value.walkabout(self)
        node.slice.walkabout(self)

    def visit_Starred(self, node):
        node.value.walkabout(self)

    def visit_Name(self, node):
        pass

    def visit_List(self, node):
        self.visit_sequence(node.elts)

    def visit_Tuple(self, node):
        self.visit_sequence(node.elts)

    def visit_Const(self, node):
        pass

    def visit_Slice(self, node):
        if node.lower:
            node.lower.walkabout(self)
        if node.upper:
            node.upper.walkabout(self)
        if node.step:
            node.step.walkabout(self)

    def visit_ExtSlice(self, node):
        self.visit_sequence(node.dims)

    def visit_Index(self, node):
        node.value.walkabout(self)

    def visit_comprehension(self, node):
        node.target.walkabout(self)
        node.iter.walkabout(self)
        self.visit_sequence(node.ifs)

    def visit_ExceptHandler(self, node):
        if node.type:
            node.type.walkabout(self)
        self.visit_sequence(node.body)

    def visit_arguments(self, node):
        self.visit_sequence(node.args)
        if node.varargannotation:
            node.varargannotation.walkabout(self)
        self.visit_sequence(node.kwonlyargs)
        if node.kwargannotation:
            node.kwargannotation.walkabout(self)
        self.visit_sequence(node.defaults)
        self.visit_sequence(node.kw_defaults)

    def visit_arg(self, node):
        if node.annotation:
            node.annotation.walkabout(self)

    def visit_keyword(self, node):
        node.value.walkabout(self)

    def visit_alias(self, node):
        pass


<<<<<<< mine
mod.typedef = typedef.TypeDef("mod",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(mod)),
)
mod.typedef.heaptype = True

def Module_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def Module_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

def Module_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Module_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~1

_Module_field_unroller = unrolling_iterable(['body'])
def Module_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Module, w_self)
    w_self.w_body = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Module constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Module_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Module.typedef = typedef.TypeDef("Module",
    mod.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Module_get_body, Module_set_body, Module_del_body, cls=Module),
    __new__=interp2app(get_AST_new(Module)),
    __init__=interp2app(Module_init),
)
Module.typedef.heaptype = True

def Interactive_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def Interactive_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

def Interactive_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Interactive_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~1

_Interactive_field_unroller = unrolling_iterable(['body'])
def Interactive_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Interactive, w_self)
    w_self.w_body = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Interactive constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Interactive_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Interactive.typedef = typedef.TypeDef("Interactive",
    mod.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Interactive_get_body, Interactive_set_body, Interactive_del_body, cls=Interactive),
    __new__=interp2app(get_AST_new(Interactive)),
    __init__=interp2app(Interactive_init),
)
Interactive.typedef.heaptype = True

def Expression_get_body(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'body')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'body')
    return space.wrap(w_self.body)

def Expression_set_body(space, w_self, w_new_value):
    try:
        w_self.body = space.interp_w(expr, w_new_value, False)
        if type(w_self.body) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'body', w_new_value)
        w_self.initialization_state &= ~1
        return
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state |= 1

def Expression_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Expression_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~1

_Expression_field_unroller = unrolling_iterable(['body'])
def Expression_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Expression, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Expression constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Expression_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Expression.typedef = typedef.TypeDef("Expression",
    mod.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Expression_get_body, Expression_set_body, Expression_del_body, cls=Expression),
    __new__=interp2app(get_AST_new(Expression)),
    __init__=interp2app(Expression_init),
)
Expression.typedef.heaptype = True

def Suite_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def Suite_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

def Suite_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Suite_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~1

_Suite_field_unroller = unrolling_iterable(['body'])
def Suite_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Suite, w_self)
    w_self.w_body = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Suite constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Suite_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Suite.typedef = typedef.TypeDef("Suite",
    mod.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Suite_get_body, Suite_set_body, Suite_del_body, cls=Suite),
    __new__=interp2app(get_AST_new(Suite)),
    __init__=interp2app(Suite_init),
)
Suite.typedef.heaptype = True

def stmt_get_lineno(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'lineno')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'lineno')
    return space.wrap(w_self.lineno)

def stmt_set_lineno(space, w_self, w_new_value):
    try:
        w_self.lineno = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'lineno', w_new_value)
        w_self.initialization_state &= ~1
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'lineno', w_new_value)
    w_self.initialization_state |= 1

def stmt_del_lineno(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    stmt_get_lineno(space, w_self)
    w_self.deldictvalue(space, 'lineno')
    w_self.initialization_state &= ~1

def stmt_get_col_offset(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'col_offset')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'col_offset')
    return space.wrap(w_self.col_offset)

def stmt_set_col_offset(space, w_self, w_new_value):
    try:
        w_self.col_offset = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'col_offset', w_new_value)
        w_self.initialization_state &= ~2
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'col_offset', w_new_value)
    w_self.initialization_state |= 2

def stmt_del_col_offset(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    stmt_get_col_offset(space, w_self)
    w_self.deldictvalue(space, 'col_offset')
    w_self.initialization_state &= ~2

stmt.typedef = typedef.TypeDef("stmt",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper(['lineno', 'col_offset']),
    lineno=typedef.GetSetProperty(stmt_get_lineno, stmt_set_lineno, stmt_del_lineno, cls=stmt),
    col_offset=typedef.GetSetProperty(stmt_get_col_offset, stmt_set_col_offset, stmt_del_col_offset, cls=stmt),
    __new__=interp2app(get_AST_new(stmt)),
)
stmt.typedef.heaptype = True

def FunctionDef_get_name(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'name')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'name')
    if w_self.name is None:
        return space.w_None
    return space.wrap(w_self.name.decode('utf-8'))

def FunctionDef_set_name(space, w_self, w_new_value):
    try:
        w_self.name = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'name', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'name', w_new_value)
    w_self.initialization_state |= 4

def FunctionDef_del_name(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    FunctionDef_get_name(space, w_self)
    w_self.deldictvalue(space, 'name')
    w_self.initialization_state &= ~4

def FunctionDef_get_args(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'args')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'args')
    return space.wrap(w_self.args)

def FunctionDef_set_args(space, w_self, w_new_value):
    try:
        w_self.args = space.interp_w(arguments, w_new_value, False)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'args', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'args')
    w_self.initialization_state |= 8

def FunctionDef_del_args(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    FunctionDef_get_args(space, w_self)
    w_self.deldictvalue(space, 'args')
    w_self.initialization_state &= ~8

def FunctionDef_get_body(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def FunctionDef_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 16

def FunctionDef_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    FunctionDef_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~16

def FunctionDef_get_decorator_list(space, w_self):
    if not w_self.initialization_state & 32:
        raise_attriberr(space, w_self, 'decorator_list')
    if w_self.w_decorator_list is None:
        if w_self.decorator_list is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.decorator_list]
        w_list = space.newlist(list_w)
        w_self.w_decorator_list = w_list
    return w_self.w_decorator_list

def FunctionDef_set_decorator_list(space, w_self, w_new_value):
    w_self.w_decorator_list = w_new_value
    w_self.initialization_state |= 32

def FunctionDef_del_decorator_list(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    FunctionDef_get_decorator_list(space, w_self)
    w_self.deldictvalue(space, 'decorator_list')
    w_self.initialization_state &= ~32

def FunctionDef_get_returns(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'returns')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 64:
        raise_attriberr(space, w_self, 'returns')
    return space.wrap(w_self.returns)

def FunctionDef_set_returns(space, w_self, w_new_value):
    try:
        w_self.returns = space.interp_w(expr, w_new_value, True)
        if type(w_self.returns) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'returns', w_new_value)
        w_self.initialization_state &= ~64
        return
    w_self.deldictvalue(space, 'returns')
    w_self.initialization_state |= 64

def FunctionDef_del_returns(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    FunctionDef_get_returns(space, w_self)
    w_self.deldictvalue(space, 'returns')
    w_self.initialization_state &= ~64

_FunctionDef_field_unroller = unrolling_iterable(['name', 'args', 'body', 'decorator_list', 'returns'])
def FunctionDef_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(FunctionDef, w_self)
    w_self.w_body = None
    w_self.w_decorator_list = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("FunctionDef constructor takes either 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _FunctionDef_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

FunctionDef.typedef = typedef.TypeDef("FunctionDef",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['name', 'args', 'body', 'decorator_list', 'returns']),
    name=typedef.GetSetProperty(FunctionDef_get_name, FunctionDef_set_name, FunctionDef_del_name, cls=FunctionDef),
    args=typedef.GetSetProperty(FunctionDef_get_args, FunctionDef_set_args, FunctionDef_del_args, cls=FunctionDef),
    body=typedef.GetSetProperty(FunctionDef_get_body, FunctionDef_set_body, FunctionDef_del_body, cls=FunctionDef),
    decorator_list=typedef.GetSetProperty(FunctionDef_get_decorator_list, FunctionDef_set_decorator_list, FunctionDef_del_decorator_list, cls=FunctionDef),
    returns=typedef.GetSetProperty(FunctionDef_get_returns, FunctionDef_set_returns, FunctionDef_del_returns, cls=FunctionDef),
    __new__=interp2app(get_AST_new(FunctionDef)),
    __init__=interp2app(FunctionDef_init),
)
FunctionDef.typedef.heaptype = True

def ClassDef_get_name(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'name')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'name')
    if w_self.name is None:
        return space.w_None
    return space.wrap(w_self.name.decode('utf-8'))

def ClassDef_set_name(space, w_self, w_new_value):
    try:
        w_self.name = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'name', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'name', w_new_value)
    w_self.initialization_state |= 4

def ClassDef_del_name(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_name(space, w_self)
    w_self.deldictvalue(space, 'name')
    w_self.initialization_state &= ~4

def ClassDef_get_bases(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'bases')
    if w_self.w_bases is None:
        if w_self.bases is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.bases]
        w_list = space.newlist(list_w)
        w_self.w_bases = w_list
    return w_self.w_bases

def ClassDef_set_bases(space, w_self, w_new_value):
    w_self.w_bases = w_new_value
    w_self.initialization_state |= 8

def ClassDef_del_bases(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_bases(space, w_self)
    w_self.deldictvalue(space, 'bases')
    w_self.initialization_state &= ~8

def ClassDef_get_keywords(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'keywords')
    if w_self.w_keywords is None:
        if w_self.keywords is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.keywords]
        w_list = space.newlist(list_w)
        w_self.w_keywords = w_list
    return w_self.w_keywords

def ClassDef_set_keywords(space, w_self, w_new_value):
    w_self.w_keywords = w_new_value
    w_self.initialization_state |= 16

def ClassDef_del_keywords(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_keywords(space, w_self)
    w_self.deldictvalue(space, 'keywords')
    w_self.initialization_state &= ~16

def ClassDef_get_starargs(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'starargs')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 32:
        raise_attriberr(space, w_self, 'starargs')
    return space.wrap(w_self.starargs)

def ClassDef_set_starargs(space, w_self, w_new_value):
    try:
        w_self.starargs = space.interp_w(expr, w_new_value, True)
        if type(w_self.starargs) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'starargs', w_new_value)
        w_self.initialization_state &= ~32
        return
    w_self.deldictvalue(space, 'starargs')
    w_self.initialization_state |= 32

def ClassDef_del_starargs(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_starargs(space, w_self)
    w_self.deldictvalue(space, 'starargs')
    w_self.initialization_state &= ~32

def ClassDef_get_kwargs(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'kwargs')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 64:
        raise_attriberr(space, w_self, 'kwargs')
    return space.wrap(w_self.kwargs)

def ClassDef_set_kwargs(space, w_self, w_new_value):
    try:
        w_self.kwargs = space.interp_w(expr, w_new_value, True)
        if type(w_self.kwargs) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'kwargs', w_new_value)
        w_self.initialization_state &= ~64
        return
    w_self.deldictvalue(space, 'kwargs')
    w_self.initialization_state |= 64

def ClassDef_del_kwargs(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_kwargs(space, w_self)
    w_self.deldictvalue(space, 'kwargs')
    w_self.initialization_state &= ~64

def ClassDef_get_body(space, w_self):
    if not w_self.initialization_state & 128:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def ClassDef_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 128

def ClassDef_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~128

def ClassDef_get_decorator_list(space, w_self):
    if not w_self.initialization_state & 256:
        raise_attriberr(space, w_self, 'decorator_list')
    if w_self.w_decorator_list is None:
        if w_self.decorator_list is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.decorator_list]
        w_list = space.newlist(list_w)
        w_self.w_decorator_list = w_list
    return w_self.w_decorator_list

def ClassDef_set_decorator_list(space, w_self, w_new_value):
    w_self.w_decorator_list = w_new_value
    w_self.initialization_state |= 256

def ClassDef_del_decorator_list(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ClassDef_get_decorator_list(space, w_self)
    w_self.deldictvalue(space, 'decorator_list')
    w_self.initialization_state &= ~256

_ClassDef_field_unroller = unrolling_iterable(['name', 'bases', 'keywords', 'starargs', 'kwargs', 'body', 'decorator_list'])
def ClassDef_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(ClassDef, w_self)
    w_self.w_bases = None
    w_self.w_keywords = None
    w_self.w_body = None
    w_self.w_decorator_list = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 7:
            w_err = space.wrap("ClassDef constructor takes either 0 or 7 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ClassDef_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

ClassDef.typedef = typedef.TypeDef("ClassDef",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['name', 'bases', 'keywords', 'starargs', 'kwargs', 'body', 'decorator_list']),
    name=typedef.GetSetProperty(ClassDef_get_name, ClassDef_set_name, ClassDef_del_name, cls=ClassDef),
    bases=typedef.GetSetProperty(ClassDef_get_bases, ClassDef_set_bases, ClassDef_del_bases, cls=ClassDef),
    keywords=typedef.GetSetProperty(ClassDef_get_keywords, ClassDef_set_keywords, ClassDef_del_keywords, cls=ClassDef),
    starargs=typedef.GetSetProperty(ClassDef_get_starargs, ClassDef_set_starargs, ClassDef_del_starargs, cls=ClassDef),
    kwargs=typedef.GetSetProperty(ClassDef_get_kwargs, ClassDef_set_kwargs, ClassDef_del_kwargs, cls=ClassDef),
    body=typedef.GetSetProperty(ClassDef_get_body, ClassDef_set_body, ClassDef_del_body, cls=ClassDef),
    decorator_list=typedef.GetSetProperty(ClassDef_get_decorator_list, ClassDef_set_decorator_list, ClassDef_del_decorator_list, cls=ClassDef),
    __new__=interp2app(get_AST_new(ClassDef)),
    __init__=interp2app(ClassDef_init),
)
ClassDef.typedef.heaptype = True

def Return_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Return_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, True)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 4

def Return_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Return_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

_Return_field_unroller = unrolling_iterable(['value'])
def Return_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Return, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Return constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Return_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Return.typedef = typedef.TypeDef("Return",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Return_get_value, Return_set_value, Return_del_value, cls=Return),
    __new__=interp2app(get_AST_new(Return)),
    __init__=interp2app(Return_init),
)
Return.typedef.heaptype = True

def Delete_get_targets(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'targets')
    if w_self.w_targets is None:
        if w_self.targets is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.targets]
        w_list = space.newlist(list_w)
        w_self.w_targets = w_list
    return w_self.w_targets

def Delete_set_targets(space, w_self, w_new_value):
    w_self.w_targets = w_new_value
    w_self.initialization_state |= 4

def Delete_del_targets(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Delete_get_targets(space, w_self)
    w_self.deldictvalue(space, 'targets')
    w_self.initialization_state &= ~4

_Delete_field_unroller = unrolling_iterable(['targets'])
def Delete_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Delete, w_self)
    w_self.w_targets = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Delete constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Delete_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Delete.typedef = typedef.TypeDef("Delete",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['targets']),
    targets=typedef.GetSetProperty(Delete_get_targets, Delete_set_targets, Delete_del_targets, cls=Delete),
    __new__=interp2app(get_AST_new(Delete)),
    __init__=interp2app(Delete_init),
)
Delete.typedef.heaptype = True

def Assign_get_targets(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'targets')
    if w_self.w_targets is None:
        if w_self.targets is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.targets]
        w_list = space.newlist(list_w)
        w_self.w_targets = w_list
    return w_self.w_targets

def Assign_set_targets(space, w_self, w_new_value):
    w_self.w_targets = w_new_value
    w_self.initialization_state |= 4

def Assign_del_targets(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Assign_get_targets(space, w_self)
    w_self.deldictvalue(space, 'targets')
    w_self.initialization_state &= ~4

def Assign_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Assign_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 8

def Assign_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Assign_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~8

_Assign_field_unroller = unrolling_iterable(['targets', 'value'])
def Assign_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Assign, w_self)
    w_self.w_targets = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Assign constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Assign_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Assign.typedef = typedef.TypeDef("Assign",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['targets', 'value']),
    targets=typedef.GetSetProperty(Assign_get_targets, Assign_set_targets, Assign_del_targets, cls=Assign),
    value=typedef.GetSetProperty(Assign_get_value, Assign_set_value, Assign_del_value, cls=Assign),
    __new__=interp2app(get_AST_new(Assign)),
    __init__=interp2app(Assign_init),
)
Assign.typedef.heaptype = True

def AugAssign_get_target(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'target')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'target')
    return space.wrap(w_self.target)

def AugAssign_set_target(space, w_self, w_new_value):
    try:
        w_self.target = space.interp_w(expr, w_new_value, False)
        if type(w_self.target) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'target', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'target')
    w_self.initialization_state |= 4

def AugAssign_del_target(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    AugAssign_get_target(space, w_self)
    w_self.deldictvalue(space, 'target')
    w_self.initialization_state &= ~4

def AugAssign_get_op(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'op')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'op')
    return operator_to_class[w_self.op - 1]()

def AugAssign_set_op(space, w_self, w_new_value):
    try:
        obj = space.interp_w(operator, w_new_value)
        w_self.op = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'op', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'op', w_new_value)
    w_self.initialization_state |= 8

def AugAssign_del_op(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    AugAssign_get_op(space, w_self)
    w_self.deldictvalue(space, 'op')
    w_self.initialization_state &= ~8

def AugAssign_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def AugAssign_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~16
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 16

def AugAssign_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    AugAssign_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~16

_AugAssign_field_unroller = unrolling_iterable(['target', 'op', 'value'])
def AugAssign_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(AugAssign, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("AugAssign constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _AugAssign_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

AugAssign.typedef = typedef.TypeDef("AugAssign",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['target', 'op', 'value']),
    target=typedef.GetSetProperty(AugAssign_get_target, AugAssign_set_target, AugAssign_del_target, cls=AugAssign),
    op=typedef.GetSetProperty(AugAssign_get_op, AugAssign_set_op, AugAssign_del_op, cls=AugAssign),
    value=typedef.GetSetProperty(AugAssign_get_value, AugAssign_set_value, AugAssign_del_value, cls=AugAssign),
    __new__=interp2app(get_AST_new(AugAssign)),
    __init__=interp2app(AugAssign_init),
)
AugAssign.typedef.heaptype = True

def For_get_target(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'target')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'target')
    return space.wrap(w_self.target)

def For_set_target(space, w_self, w_new_value):
    try:
        w_self.target = space.interp_w(expr, w_new_value, False)
        if type(w_self.target) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'target', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'target')
    w_self.initialization_state |= 4

def For_del_target(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    For_get_target(space, w_self)
    w_self.deldictvalue(space, 'target')
    w_self.initialization_state &= ~4

def For_get_iter(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'iter')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'iter')
    return space.wrap(w_self.iter)

def For_set_iter(space, w_self, w_new_value):
    try:
        w_self.iter = space.interp_w(expr, w_new_value, False)
        if type(w_self.iter) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'iter', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'iter')
    w_self.initialization_state |= 8

def For_del_iter(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    For_get_iter(space, w_self)
    w_self.deldictvalue(space, 'iter')
    w_self.initialization_state &= ~8

def For_get_body(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def For_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 16

def For_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    For_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~16

def For_get_orelse(space, w_self):
    if not w_self.initialization_state & 32:
        raise_attriberr(space, w_self, 'orelse')
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
        w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def For_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 32

def For_del_orelse(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    For_get_orelse(space, w_self)
    w_self.deldictvalue(space, 'orelse')
    w_self.initialization_state &= ~32

_For_field_unroller = unrolling_iterable(['target', 'iter', 'body', 'orelse'])
def For_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(For, w_self)
    w_self.w_body = None
    w_self.w_orelse = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("For constructor takes either 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _For_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

For.typedef = typedef.TypeDef("For",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['target', 'iter', 'body', 'orelse']),
    target=typedef.GetSetProperty(For_get_target, For_set_target, For_del_target, cls=For),
    iter=typedef.GetSetProperty(For_get_iter, For_set_iter, For_del_iter, cls=For),
    body=typedef.GetSetProperty(For_get_body, For_set_body, For_del_body, cls=For),
    orelse=typedef.GetSetProperty(For_get_orelse, For_set_orelse, For_del_orelse, cls=For),
    __new__=interp2app(get_AST_new(For)),
    __init__=interp2app(For_init),
)
For.typedef.heaptype = True

def While_get_test(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'test')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'test')
    return space.wrap(w_self.test)

def While_set_test(space, w_self, w_new_value):
    try:
        w_self.test = space.interp_w(expr, w_new_value, False)
        if type(w_self.test) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'test', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state |= 4

def While_del_test(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    While_get_test(space, w_self)
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state &= ~4

def While_get_body(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def While_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 8

def While_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    While_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~8

def While_get_orelse(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'orelse')
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
        w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def While_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 16

def While_del_orelse(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    While_get_orelse(space, w_self)
    w_self.deldictvalue(space, 'orelse')
    w_self.initialization_state &= ~16

_While_field_unroller = unrolling_iterable(['test', 'body', 'orelse'])
def While_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(While, w_self)
    w_self.w_body = None
    w_self.w_orelse = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("While constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _While_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

While.typedef = typedef.TypeDef("While",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['test', 'body', 'orelse']),
    test=typedef.GetSetProperty(While_get_test, While_set_test, While_del_test, cls=While),
    body=typedef.GetSetProperty(While_get_body, While_set_body, While_del_body, cls=While),
    orelse=typedef.GetSetProperty(While_get_orelse, While_set_orelse, While_del_orelse, cls=While),
    __new__=interp2app(get_AST_new(While)),
    __init__=interp2app(While_init),
)
While.typedef.heaptype = True

def If_get_test(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'test')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'test')
    return space.wrap(w_self.test)

def If_set_test(space, w_self, w_new_value):
    try:
        w_self.test = space.interp_w(expr, w_new_value, False)
        if type(w_self.test) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'test', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state |= 4

def If_del_test(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    If_get_test(space, w_self)
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state &= ~4

def If_get_body(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def If_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 8

def If_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    If_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~8

def If_get_orelse(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'orelse')
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
        w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def If_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 16

def If_del_orelse(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    If_get_orelse(space, w_self)
    w_self.deldictvalue(space, 'orelse')
    w_self.initialization_state &= ~16

_If_field_unroller = unrolling_iterable(['test', 'body', 'orelse'])
def If_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(If, w_self)
    w_self.w_body = None
    w_self.w_orelse = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("If constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _If_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

If.typedef = typedef.TypeDef("If",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['test', 'body', 'orelse']),
    test=typedef.GetSetProperty(If_get_test, If_set_test, If_del_test, cls=If),
    body=typedef.GetSetProperty(If_get_body, If_set_body, If_del_body, cls=If),
    orelse=typedef.GetSetProperty(If_get_orelse, If_set_orelse, If_del_orelse, cls=If),
    __new__=interp2app(get_AST_new(If)),
    __init__=interp2app(If_init),
)
If.typedef.heaptype = True

def With_get_context_expr(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'context_expr')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'context_expr')
    return space.wrap(w_self.context_expr)

def With_set_context_expr(space, w_self, w_new_value):
    try:
        w_self.context_expr = space.interp_w(expr, w_new_value, False)
        if type(w_self.context_expr) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'context_expr', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'context_expr')
    w_self.initialization_state |= 4

def With_del_context_expr(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    With_get_context_expr(space, w_self)
    w_self.deldictvalue(space, 'context_expr')
    w_self.initialization_state &= ~4

def With_get_optional_vars(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'optional_vars')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'optional_vars')
    return space.wrap(w_self.optional_vars)

def With_set_optional_vars(space, w_self, w_new_value):
    try:
        w_self.optional_vars = space.interp_w(expr, w_new_value, True)
        if type(w_self.optional_vars) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'optional_vars', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'optional_vars')
    w_self.initialization_state |= 8

def With_del_optional_vars(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    With_get_optional_vars(space, w_self)
    w_self.deldictvalue(space, 'optional_vars')
    w_self.initialization_state &= ~8

def With_get_body(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def With_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 16

def With_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    With_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~16

_With_field_unroller = unrolling_iterable(['context_expr', 'optional_vars', 'body'])
def With_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(With, w_self)
    w_self.w_body = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("With constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _With_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

With.typedef = typedef.TypeDef("With",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['context_expr', 'optional_vars', 'body']),
    context_expr=typedef.GetSetProperty(With_get_context_expr, With_set_context_expr, With_del_context_expr, cls=With),
    optional_vars=typedef.GetSetProperty(With_get_optional_vars, With_set_optional_vars, With_del_optional_vars, cls=With),
    body=typedef.GetSetProperty(With_get_body, With_set_body, With_del_body, cls=With),
    __new__=interp2app(get_AST_new(With)),
    __init__=interp2app(With_init),
)
With.typedef.heaptype = True

def Raise_get_exc(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'exc')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'exc')
    return space.wrap(w_self.exc)

def Raise_set_exc(space, w_self, w_new_value):
    try:
        w_self.exc = space.interp_w(expr, w_new_value, True)
        if type(w_self.exc) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'exc', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'exc')
    w_self.initialization_state |= 4

def Raise_del_exc(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Raise_get_exc(space, w_self)
    w_self.deldictvalue(space, 'exc')
    w_self.initialization_state &= ~4

def Raise_get_cause(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'cause')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'cause')
    return space.wrap(w_self.cause)

def Raise_set_cause(space, w_self, w_new_value):
    try:
        w_self.cause = space.interp_w(expr, w_new_value, True)
        if type(w_self.cause) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'cause', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'cause')
    w_self.initialization_state |= 8

def Raise_del_cause(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Raise_get_cause(space, w_self)
    w_self.deldictvalue(space, 'cause')
    w_self.initialization_state &= ~8

_Raise_field_unroller = unrolling_iterable(['exc', 'cause'])
def Raise_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Raise, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Raise constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Raise_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Raise.typedef = typedef.TypeDef("Raise",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['exc', 'cause']),
    exc=typedef.GetSetProperty(Raise_get_exc, Raise_set_exc, Raise_del_exc, cls=Raise),
    cause=typedef.GetSetProperty(Raise_get_cause, Raise_set_cause, Raise_del_cause, cls=Raise),
    __new__=interp2app(get_AST_new(Raise)),
    __init__=interp2app(Raise_init),
)
Raise.typedef.heaptype = True

def TryExcept_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def TryExcept_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

def TryExcept_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    TryExcept_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~4

def TryExcept_get_handlers(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'handlers')
    if w_self.w_handlers is None:
        if w_self.handlers is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.handlers]
        w_list = space.newlist(list_w)
        w_self.w_handlers = w_list
    return w_self.w_handlers

def TryExcept_set_handlers(space, w_self, w_new_value):
    w_self.w_handlers = w_new_value
    w_self.initialization_state |= 8

def TryExcept_del_handlers(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    TryExcept_get_handlers(space, w_self)
    w_self.deldictvalue(space, 'handlers')
    w_self.initialization_state &= ~8

def TryExcept_get_orelse(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'orelse')
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
        w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def TryExcept_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 16

def TryExcept_del_orelse(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    TryExcept_get_orelse(space, w_self)
    w_self.deldictvalue(space, 'orelse')
    w_self.initialization_state &= ~16

_TryExcept_field_unroller = unrolling_iterable(['body', 'handlers', 'orelse'])
def TryExcept_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(TryExcept, w_self)
    w_self.w_body = None
    w_self.w_handlers = None
    w_self.w_orelse = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("TryExcept constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _TryExcept_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

TryExcept.typedef = typedef.TypeDef("TryExcept",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['body', 'handlers', 'orelse']),
    body=typedef.GetSetProperty(TryExcept_get_body, TryExcept_set_body, TryExcept_del_body, cls=TryExcept),
    handlers=typedef.GetSetProperty(TryExcept_get_handlers, TryExcept_set_handlers, TryExcept_del_handlers, cls=TryExcept),
    orelse=typedef.GetSetProperty(TryExcept_get_orelse, TryExcept_set_orelse, TryExcept_del_orelse, cls=TryExcept),
    __new__=interp2app(get_AST_new(TryExcept)),
    __init__=interp2app(TryExcept_init),
)
TryExcept.typedef.heaptype = True

def TryFinally_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def TryFinally_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

def TryFinally_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    TryFinally_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~4

def TryFinally_get_finalbody(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'finalbody')
    if w_self.w_finalbody is None:
        if w_self.finalbody is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.finalbody]
        w_list = space.newlist(list_w)
        w_self.w_finalbody = w_list
    return w_self.w_finalbody

def TryFinally_set_finalbody(space, w_self, w_new_value):
    w_self.w_finalbody = w_new_value
    w_self.initialization_state |= 8

def TryFinally_del_finalbody(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    TryFinally_get_finalbody(space, w_self)
    w_self.deldictvalue(space, 'finalbody')
    w_self.initialization_state &= ~8

_TryFinally_field_unroller = unrolling_iterable(['body', 'finalbody'])
def TryFinally_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(TryFinally, w_self)
    w_self.w_body = None
    w_self.w_finalbody = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("TryFinally constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _TryFinally_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

TryFinally.typedef = typedef.TypeDef("TryFinally",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['body', 'finalbody']),
    body=typedef.GetSetProperty(TryFinally_get_body, TryFinally_set_body, TryFinally_del_body, cls=TryFinally),
    finalbody=typedef.GetSetProperty(TryFinally_get_finalbody, TryFinally_set_finalbody, TryFinally_del_finalbody, cls=TryFinally),
    __new__=interp2app(get_AST_new(TryFinally)),
    __init__=interp2app(TryFinally_init),
)
TryFinally.typedef.heaptype = True

def Assert_get_test(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'test')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'test')
    return space.wrap(w_self.test)

def Assert_set_test(space, w_self, w_new_value):
    try:
        w_self.test = space.interp_w(expr, w_new_value, False)
        if type(w_self.test) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'test', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state |= 4

def Assert_del_test(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Assert_get_test(space, w_self)
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state &= ~4

def Assert_get_msg(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'msg')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'msg')
    return space.wrap(w_self.msg)

def Assert_set_msg(space, w_self, w_new_value):
    try:
        w_self.msg = space.interp_w(expr, w_new_value, True)
        if type(w_self.msg) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'msg', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'msg')
    w_self.initialization_state |= 8

def Assert_del_msg(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Assert_get_msg(space, w_self)
    w_self.deldictvalue(space, 'msg')
    w_self.initialization_state &= ~8

_Assert_field_unroller = unrolling_iterable(['test', 'msg'])
def Assert_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Assert, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Assert constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Assert_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Assert.typedef = typedef.TypeDef("Assert",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['test', 'msg']),
    test=typedef.GetSetProperty(Assert_get_test, Assert_set_test, Assert_del_test, cls=Assert),
    msg=typedef.GetSetProperty(Assert_get_msg, Assert_set_msg, Assert_del_msg, cls=Assert),
    __new__=interp2app(get_AST_new(Assert)),
    __init__=interp2app(Assert_init),
)
Assert.typedef.heaptype = True

def Import_get_names(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'names')
    if w_self.w_names is None:
        if w_self.names is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.names]
        w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def Import_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 4

def Import_del_names(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Import_get_names(space, w_self)
    w_self.deldictvalue(space, 'names')
    w_self.initialization_state &= ~4

_Import_field_unroller = unrolling_iterable(['names'])
def Import_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Import, w_self)
    w_self.w_names = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Import constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Import_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Import.typedef = typedef.TypeDef("Import",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['names']),
    names=typedef.GetSetProperty(Import_get_names, Import_set_names, Import_del_names, cls=Import),
    __new__=interp2app(get_AST_new(Import)),
    __init__=interp2app(Import_init),
)
Import.typedef.heaptype = True

def ImportFrom_get_module(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'module')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'module')
    if w_self.module is None:
        return space.w_None
    return space.wrap(w_self.module.decode('utf-8'))

def ImportFrom_set_module(space, w_self, w_new_value):
    try:
        if space.is_w(w_new_value, space.w_None):
            w_self.module = None
        else:
            w_self.module = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'module', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'module', w_new_value)
    w_self.initialization_state |= 4

def ImportFrom_del_module(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ImportFrom_get_module(space, w_self)
    w_self.deldictvalue(space, 'module')
    w_self.initialization_state &= ~4

def ImportFrom_get_names(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'names')
    if w_self.w_names is None:
        if w_self.names is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.names]
        w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def ImportFrom_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 8

def ImportFrom_del_names(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ImportFrom_get_names(space, w_self)
    w_self.deldictvalue(space, 'names')
    w_self.initialization_state &= ~8

def ImportFrom_get_level(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'level')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'level')
    return space.wrap(w_self.level)

def ImportFrom_set_level(space, w_self, w_new_value):
    try:
        w_self.level = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'level', w_new_value)
        w_self.initialization_state &= ~16
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'level', w_new_value)
    w_self.initialization_state |= 16

def ImportFrom_del_level(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ImportFrom_get_level(space, w_self)
    w_self.deldictvalue(space, 'level')
    w_self.initialization_state &= ~16

_ImportFrom_field_unroller = unrolling_iterable(['module', 'names', 'level'])
def ImportFrom_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(ImportFrom, w_self)
    w_self.w_names = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("ImportFrom constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ImportFrom_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

ImportFrom.typedef = typedef.TypeDef("ImportFrom",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['module', 'names', 'level']),
    module=typedef.GetSetProperty(ImportFrom_get_module, ImportFrom_set_module, ImportFrom_del_module, cls=ImportFrom),
    names=typedef.GetSetProperty(ImportFrom_get_names, ImportFrom_set_names, ImportFrom_del_names, cls=ImportFrom),
    level=typedef.GetSetProperty(ImportFrom_get_level, ImportFrom_set_level, ImportFrom_del_level, cls=ImportFrom),
    __new__=interp2app(get_AST_new(ImportFrom)),
    __init__=interp2app(ImportFrom_init),
)
ImportFrom.typedef.heaptype = True

def Global_get_names(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'names')
    if w_self.w_names is None:
        if w_self.names is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.names]
        w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def Global_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 4

def Global_del_names(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Global_get_names(space, w_self)
    w_self.deldictvalue(space, 'names')
    w_self.initialization_state &= ~4

_Global_field_unroller = unrolling_iterable(['names'])
def Global_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Global, w_self)
    w_self.w_names = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Global constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Global_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Global.typedef = typedef.TypeDef("Global",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['names']),
    names=typedef.GetSetProperty(Global_get_names, Global_set_names, Global_del_names, cls=Global),
    __new__=interp2app(get_AST_new(Global)),
    __init__=interp2app(Global_init),
)
Global.typedef.heaptype = True

def Nonlocal_get_names(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'names')
    if w_self.w_names is None:
        if w_self.names is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.names]
        w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def Nonlocal_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 4

def Nonlocal_del_names(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Nonlocal_get_names(space, w_self)
    w_self.deldictvalue(space, 'names')
    w_self.initialization_state &= ~4

_Nonlocal_field_unroller = unrolling_iterable(['names'])
def Nonlocal_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Nonlocal, w_self)
    w_self.w_names = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Nonlocal constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Nonlocal_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Nonlocal.typedef = typedef.TypeDef("Nonlocal",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['names']),
    names=typedef.GetSetProperty(Nonlocal_get_names, Nonlocal_set_names, Nonlocal_del_names, cls=Nonlocal),
    __new__=interp2app(get_AST_new(Nonlocal)),
    __init__=interp2app(Nonlocal_init),
)
Nonlocal.typedef.heaptype = True

def Expr_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Expr_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 4

def Expr_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Expr_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

_Expr_field_unroller = unrolling_iterable(['value'])
def Expr_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Expr, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Expr constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Expr_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Expr.typedef = typedef.TypeDef("Expr",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Expr_get_value, Expr_set_value, Expr_del_value, cls=Expr),
    __new__=interp2app(get_AST_new(Expr)),
    __init__=interp2app(Expr_init),
)
Expr.typedef.heaptype = True

def Pass_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Pass, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        w_err = space.wrap("Pass constructor takes no arguments")
        raise OperationError(space.w_TypeError, w_err)
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Pass.typedef = typedef.TypeDef("Pass",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Pass)),
    __init__=interp2app(Pass_init),
)
Pass.typedef.heaptype = True

def Break_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Break, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        w_err = space.wrap("Break constructor takes no arguments")
        raise OperationError(space.w_TypeError, w_err)
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Break.typedef = typedef.TypeDef("Break",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Break)),
    __init__=interp2app(Break_init),
)
Break.typedef.heaptype = True

def Continue_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Continue, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        w_err = space.wrap("Continue constructor takes no arguments")
        raise OperationError(space.w_TypeError, w_err)
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Continue.typedef = typedef.TypeDef("Continue",
    stmt.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Continue)),
    __init__=interp2app(Continue_init),
)
Continue.typedef.heaptype = True

def expr_get_lineno(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'lineno')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'lineno')
    return space.wrap(w_self.lineno)

def expr_set_lineno(space, w_self, w_new_value):
    try:
        w_self.lineno = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'lineno', w_new_value)
        w_self.initialization_state &= ~1
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'lineno', w_new_value)
    w_self.initialization_state |= 1

def expr_del_lineno(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    expr_get_lineno(space, w_self)
    w_self.deldictvalue(space, 'lineno')
    w_self.initialization_state &= ~1

def expr_get_col_offset(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'col_offset')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'col_offset')
    return space.wrap(w_self.col_offset)

def expr_set_col_offset(space, w_self, w_new_value):
    try:
        w_self.col_offset = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'col_offset', w_new_value)
        w_self.initialization_state &= ~2
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'col_offset', w_new_value)
    w_self.initialization_state |= 2

def expr_del_col_offset(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    expr_get_col_offset(space, w_self)
    w_self.deldictvalue(space, 'col_offset')
    w_self.initialization_state &= ~2

expr.typedef = typedef.TypeDef("expr",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper(['lineno', 'col_offset']),
    lineno=typedef.GetSetProperty(expr_get_lineno, expr_set_lineno, expr_del_lineno, cls=expr),
    col_offset=typedef.GetSetProperty(expr_get_col_offset, expr_set_col_offset, expr_del_col_offset, cls=expr),
    __new__=interp2app(get_AST_new(expr)),
)
expr.typedef.heaptype = True

def BoolOp_get_op(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'op')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'op')
    return boolop_to_class[w_self.op - 1]()

def BoolOp_set_op(space, w_self, w_new_value):
    try:
        obj = space.interp_w(boolop, w_new_value)
        w_self.op = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'op', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'op', w_new_value)
    w_self.initialization_state |= 4

def BoolOp_del_op(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    BoolOp_get_op(space, w_self)
    w_self.deldictvalue(space, 'op')
    w_self.initialization_state &= ~4

def BoolOp_get_values(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'values')
    if w_self.w_values is None:
        if w_self.values is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.values]
        w_list = space.newlist(list_w)
        w_self.w_values = w_list
    return w_self.w_values

def BoolOp_set_values(space, w_self, w_new_value):
    w_self.w_values = w_new_value
    w_self.initialization_state |= 8

def BoolOp_del_values(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    BoolOp_get_values(space, w_self)
    w_self.deldictvalue(space, 'values')
    w_self.initialization_state &= ~8

_BoolOp_field_unroller = unrolling_iterable(['op', 'values'])
def BoolOp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(BoolOp, w_self)
    w_self.w_values = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("BoolOp constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _BoolOp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

BoolOp.typedef = typedef.TypeDef("BoolOp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['op', 'values']),
    op=typedef.GetSetProperty(BoolOp_get_op, BoolOp_set_op, BoolOp_del_op, cls=BoolOp),
    values=typedef.GetSetProperty(BoolOp_get_values, BoolOp_set_values, BoolOp_del_values, cls=BoolOp),
    __new__=interp2app(get_AST_new(BoolOp)),
    __init__=interp2app(BoolOp_init),
)
BoolOp.typedef.heaptype = True

def BinOp_get_left(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'left')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'left')
    return space.wrap(w_self.left)

def BinOp_set_left(space, w_self, w_new_value):
    try:
        w_self.left = space.interp_w(expr, w_new_value, False)
        if type(w_self.left) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'left', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'left')
    w_self.initialization_state |= 4

def BinOp_del_left(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    BinOp_get_left(space, w_self)
    w_self.deldictvalue(space, 'left')
    w_self.initialization_state &= ~4

def BinOp_get_op(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'op')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'op')
    return operator_to_class[w_self.op - 1]()

def BinOp_set_op(space, w_self, w_new_value):
    try:
        obj = space.interp_w(operator, w_new_value)
        w_self.op = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'op', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'op', w_new_value)
    w_self.initialization_state |= 8

def BinOp_del_op(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    BinOp_get_op(space, w_self)
    w_self.deldictvalue(space, 'op')
    w_self.initialization_state &= ~8

def BinOp_get_right(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'right')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'right')
    return space.wrap(w_self.right)

def BinOp_set_right(space, w_self, w_new_value):
    try:
        w_self.right = space.interp_w(expr, w_new_value, False)
        if type(w_self.right) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'right', w_new_value)
        w_self.initialization_state &= ~16
        return
    w_self.deldictvalue(space, 'right')
    w_self.initialization_state |= 16

def BinOp_del_right(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    BinOp_get_right(space, w_self)
    w_self.deldictvalue(space, 'right')
    w_self.initialization_state &= ~16

_BinOp_field_unroller = unrolling_iterable(['left', 'op', 'right'])
def BinOp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(BinOp, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("BinOp constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _BinOp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

BinOp.typedef = typedef.TypeDef("BinOp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['left', 'op', 'right']),
    left=typedef.GetSetProperty(BinOp_get_left, BinOp_set_left, BinOp_del_left, cls=BinOp),
    op=typedef.GetSetProperty(BinOp_get_op, BinOp_set_op, BinOp_del_op, cls=BinOp),
    right=typedef.GetSetProperty(BinOp_get_right, BinOp_set_right, BinOp_del_right, cls=BinOp),
    __new__=interp2app(get_AST_new(BinOp)),
    __init__=interp2app(BinOp_init),
)
BinOp.typedef.heaptype = True

def UnaryOp_get_op(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'op')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'op')
    return unaryop_to_class[w_self.op - 1]()

def UnaryOp_set_op(space, w_self, w_new_value):
    try:
        obj = space.interp_w(unaryop, w_new_value)
        w_self.op = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'op', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'op', w_new_value)
    w_self.initialization_state |= 4

def UnaryOp_del_op(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    UnaryOp_get_op(space, w_self)
    w_self.deldictvalue(space, 'op')
    w_self.initialization_state &= ~4

def UnaryOp_get_operand(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'operand')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'operand')
    return space.wrap(w_self.operand)

def UnaryOp_set_operand(space, w_self, w_new_value):
    try:
        w_self.operand = space.interp_w(expr, w_new_value, False)
        if type(w_self.operand) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'operand', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'operand')
    w_self.initialization_state |= 8

def UnaryOp_del_operand(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    UnaryOp_get_operand(space, w_self)
    w_self.deldictvalue(space, 'operand')
    w_self.initialization_state &= ~8

_UnaryOp_field_unroller = unrolling_iterable(['op', 'operand'])
def UnaryOp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(UnaryOp, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("UnaryOp constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _UnaryOp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

UnaryOp.typedef = typedef.TypeDef("UnaryOp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['op', 'operand']),
    op=typedef.GetSetProperty(UnaryOp_get_op, UnaryOp_set_op, UnaryOp_del_op, cls=UnaryOp),
    operand=typedef.GetSetProperty(UnaryOp_get_operand, UnaryOp_set_operand, UnaryOp_del_operand, cls=UnaryOp),
    __new__=interp2app(get_AST_new(UnaryOp)),
    __init__=interp2app(UnaryOp_init),
)
UnaryOp.typedef.heaptype = True

def Lambda_get_args(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'args')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'args')
    return space.wrap(w_self.args)

def Lambda_set_args(space, w_self, w_new_value):
    try:
        w_self.args = space.interp_w(arguments, w_new_value, False)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'args', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'args')
    w_self.initialization_state |= 4

def Lambda_del_args(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Lambda_get_args(space, w_self)
    w_self.deldictvalue(space, 'args')
    w_self.initialization_state &= ~4

def Lambda_get_body(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'body')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'body')
    return space.wrap(w_self.body)

def Lambda_set_body(space, w_self, w_new_value):
    try:
        w_self.body = space.interp_w(expr, w_new_value, False)
        if type(w_self.body) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'body', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state |= 8

def Lambda_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Lambda_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~8

_Lambda_field_unroller = unrolling_iterable(['args', 'body'])
def Lambda_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Lambda, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Lambda constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Lambda_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Lambda.typedef = typedef.TypeDef("Lambda",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['args', 'body']),
    args=typedef.GetSetProperty(Lambda_get_args, Lambda_set_args, Lambda_del_args, cls=Lambda),
    body=typedef.GetSetProperty(Lambda_get_body, Lambda_set_body, Lambda_del_body, cls=Lambda),
    __new__=interp2app(get_AST_new(Lambda)),
    __init__=interp2app(Lambda_init),
)
Lambda.typedef.heaptype = True

def IfExp_get_test(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'test')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'test')
    return space.wrap(w_self.test)

def IfExp_set_test(space, w_self, w_new_value):
    try:
        w_self.test = space.interp_w(expr, w_new_value, False)
        if type(w_self.test) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'test', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state |= 4

def IfExp_del_test(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    IfExp_get_test(space, w_self)
    w_self.deldictvalue(space, 'test')
    w_self.initialization_state &= ~4

def IfExp_get_body(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'body')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'body')
    return space.wrap(w_self.body)

def IfExp_set_body(space, w_self, w_new_value):
    try:
        w_self.body = space.interp_w(expr, w_new_value, False)
        if type(w_self.body) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'body', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state |= 8

def IfExp_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    IfExp_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~8

def IfExp_get_orelse(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'orelse')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'orelse')
    return space.wrap(w_self.orelse)

def IfExp_set_orelse(space, w_self, w_new_value):
    try:
        w_self.orelse = space.interp_w(expr, w_new_value, False)
        if type(w_self.orelse) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'orelse', w_new_value)
        w_self.initialization_state &= ~16
        return
    w_self.deldictvalue(space, 'orelse')
    w_self.initialization_state |= 16

def IfExp_del_orelse(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    IfExp_get_orelse(space, w_self)
    w_self.deldictvalue(space, 'orelse')
    w_self.initialization_state &= ~16

_IfExp_field_unroller = unrolling_iterable(['test', 'body', 'orelse'])
def IfExp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(IfExp, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("IfExp constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _IfExp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

IfExp.typedef = typedef.TypeDef("IfExp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['test', 'body', 'orelse']),
    test=typedef.GetSetProperty(IfExp_get_test, IfExp_set_test, IfExp_del_test, cls=IfExp),
    body=typedef.GetSetProperty(IfExp_get_body, IfExp_set_body, IfExp_del_body, cls=IfExp),
    orelse=typedef.GetSetProperty(IfExp_get_orelse, IfExp_set_orelse, IfExp_del_orelse, cls=IfExp),
    __new__=interp2app(get_AST_new(IfExp)),
    __init__=interp2app(IfExp_init),
)
IfExp.typedef.heaptype = True

def Dict_get_keys(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'keys')
    if w_self.w_keys is None:
        if w_self.keys is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.keys]
        w_list = space.newlist(list_w)
        w_self.w_keys = w_list
    return w_self.w_keys

def Dict_set_keys(space, w_self, w_new_value):
    w_self.w_keys = w_new_value
    w_self.initialization_state |= 4

def Dict_del_keys(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Dict_get_keys(space, w_self)
    w_self.deldictvalue(space, 'keys')
    w_self.initialization_state &= ~4

def Dict_get_values(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'values')
    if w_self.w_values is None:
        if w_self.values is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.values]
        w_list = space.newlist(list_w)
        w_self.w_values = w_list
    return w_self.w_values

def Dict_set_values(space, w_self, w_new_value):
    w_self.w_values = w_new_value
    w_self.initialization_state |= 8

def Dict_del_values(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Dict_get_values(space, w_self)
    w_self.deldictvalue(space, 'values')
    w_self.initialization_state &= ~8

_Dict_field_unroller = unrolling_iterable(['keys', 'values'])
def Dict_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Dict, w_self)
    w_self.w_keys = None
    w_self.w_values = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Dict constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Dict_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Dict.typedef = typedef.TypeDef("Dict",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['keys', 'values']),
    keys=typedef.GetSetProperty(Dict_get_keys, Dict_set_keys, Dict_del_keys, cls=Dict),
    values=typedef.GetSetProperty(Dict_get_values, Dict_set_values, Dict_del_values, cls=Dict),
    __new__=interp2app(get_AST_new(Dict)),
    __init__=interp2app(Dict_init),
)
Dict.typedef.heaptype = True

def Set_get_elts(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'elts')
    if w_self.w_elts is None:
        if w_self.elts is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.elts]
        w_list = space.newlist(list_w)
        w_self.w_elts = w_list
    return w_self.w_elts

def Set_set_elts(space, w_self, w_new_value):
    w_self.w_elts = w_new_value
    w_self.initialization_state |= 4

def Set_del_elts(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Set_get_elts(space, w_self)
    w_self.deldictvalue(space, 'elts')
    w_self.initialization_state &= ~4

_Set_field_unroller = unrolling_iterable(['elts'])
def Set_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Set, w_self)
    w_self.w_elts = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Set constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Set_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Set.typedef = typedef.TypeDef("Set",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['elts']),
    elts=typedef.GetSetProperty(Set_get_elts, Set_set_elts, Set_del_elts, cls=Set),
    __new__=interp2app(get_AST_new(Set)),
    __init__=interp2app(Set_init),
)
Set.typedef.heaptype = True

def ListComp_get_elt(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'elt')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'elt')
    return space.wrap(w_self.elt)

def ListComp_set_elt(space, w_self, w_new_value):
    try:
        w_self.elt = space.interp_w(expr, w_new_value, False)
        if type(w_self.elt) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'elt', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'elt')
    w_self.initialization_state |= 4

def ListComp_del_elt(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ListComp_get_elt(space, w_self)
    w_self.deldictvalue(space, 'elt')
    w_self.initialization_state &= ~4

def ListComp_get_generators(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'generators')
    if w_self.w_generators is None:
        if w_self.generators is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.generators]
        w_list = space.newlist(list_w)
        w_self.w_generators = w_list
    return w_self.w_generators

def ListComp_set_generators(space, w_self, w_new_value):
    w_self.w_generators = w_new_value
    w_self.initialization_state |= 8

def ListComp_del_generators(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ListComp_get_generators(space, w_self)
    w_self.deldictvalue(space, 'generators')
    w_self.initialization_state &= ~8

_ListComp_field_unroller = unrolling_iterable(['elt', 'generators'])
def ListComp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(ListComp, w_self)
    w_self.w_generators = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("ListComp constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ListComp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

ListComp.typedef = typedef.TypeDef("ListComp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['elt', 'generators']),
    elt=typedef.GetSetProperty(ListComp_get_elt, ListComp_set_elt, ListComp_del_elt, cls=ListComp),
    generators=typedef.GetSetProperty(ListComp_get_generators, ListComp_set_generators, ListComp_del_generators, cls=ListComp),
    __new__=interp2app(get_AST_new(ListComp)),
    __init__=interp2app(ListComp_init),
)
ListComp.typedef.heaptype = True

def SetComp_get_elt(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'elt')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'elt')
    return space.wrap(w_self.elt)

def SetComp_set_elt(space, w_self, w_new_value):
    try:
        w_self.elt = space.interp_w(expr, w_new_value, False)
        if type(w_self.elt) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'elt', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'elt')
    w_self.initialization_state |= 4

def SetComp_del_elt(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    SetComp_get_elt(space, w_self)
    w_self.deldictvalue(space, 'elt')
    w_self.initialization_state &= ~4

def SetComp_get_generators(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'generators')
    if w_self.w_generators is None:
        if w_self.generators is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.generators]
        w_list = space.newlist(list_w)
        w_self.w_generators = w_list
    return w_self.w_generators

def SetComp_set_generators(space, w_self, w_new_value):
    w_self.w_generators = w_new_value
    w_self.initialization_state |= 8

def SetComp_del_generators(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    SetComp_get_generators(space, w_self)
    w_self.deldictvalue(space, 'generators')
    w_self.initialization_state &= ~8

_SetComp_field_unroller = unrolling_iterable(['elt', 'generators'])
def SetComp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(SetComp, w_self)
    w_self.w_generators = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("SetComp constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _SetComp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

SetComp.typedef = typedef.TypeDef("SetComp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['elt', 'generators']),
    elt=typedef.GetSetProperty(SetComp_get_elt, SetComp_set_elt, SetComp_del_elt, cls=SetComp),
    generators=typedef.GetSetProperty(SetComp_get_generators, SetComp_set_generators, SetComp_del_generators, cls=SetComp),
    __new__=interp2app(get_AST_new(SetComp)),
    __init__=interp2app(SetComp_init),
)
SetComp.typedef.heaptype = True

def DictComp_get_key(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'key')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'key')
    return space.wrap(w_self.key)

def DictComp_set_key(space, w_self, w_new_value):
    try:
        w_self.key = space.interp_w(expr, w_new_value, False)
        if type(w_self.key) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'key', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'key')
    w_self.initialization_state |= 4

def DictComp_del_key(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    DictComp_get_key(space, w_self)
    w_self.deldictvalue(space, 'key')
    w_self.initialization_state &= ~4

def DictComp_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def DictComp_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 8

def DictComp_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    DictComp_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~8

def DictComp_get_generators(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'generators')
    if w_self.w_generators is None:
        if w_self.generators is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.generators]
        w_list = space.newlist(list_w)
        w_self.w_generators = w_list
    return w_self.w_generators

def DictComp_set_generators(space, w_self, w_new_value):
    w_self.w_generators = w_new_value
    w_self.initialization_state |= 16

def DictComp_del_generators(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    DictComp_get_generators(space, w_self)
    w_self.deldictvalue(space, 'generators')
    w_self.initialization_state &= ~16

_DictComp_field_unroller = unrolling_iterable(['key', 'value', 'generators'])
def DictComp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(DictComp, w_self)
    w_self.w_generators = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("DictComp constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _DictComp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

DictComp.typedef = typedef.TypeDef("DictComp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['key', 'value', 'generators']),
    key=typedef.GetSetProperty(DictComp_get_key, DictComp_set_key, DictComp_del_key, cls=DictComp),
    value=typedef.GetSetProperty(DictComp_get_value, DictComp_set_value, DictComp_del_value, cls=DictComp),
    generators=typedef.GetSetProperty(DictComp_get_generators, DictComp_set_generators, DictComp_del_generators, cls=DictComp),
    __new__=interp2app(get_AST_new(DictComp)),
    __init__=interp2app(DictComp_init),
)
DictComp.typedef.heaptype = True

def GeneratorExp_get_elt(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'elt')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'elt')
    return space.wrap(w_self.elt)

def GeneratorExp_set_elt(space, w_self, w_new_value):
    try:
        w_self.elt = space.interp_w(expr, w_new_value, False)
        if type(w_self.elt) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'elt', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'elt')
    w_self.initialization_state |= 4

def GeneratorExp_del_elt(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    GeneratorExp_get_elt(space, w_self)
    w_self.deldictvalue(space, 'elt')
    w_self.initialization_state &= ~4

def GeneratorExp_get_generators(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'generators')
    if w_self.w_generators is None:
        if w_self.generators is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.generators]
        w_list = space.newlist(list_w)
        w_self.w_generators = w_list
    return w_self.w_generators

def GeneratorExp_set_generators(space, w_self, w_new_value):
    w_self.w_generators = w_new_value
    w_self.initialization_state |= 8

def GeneratorExp_del_generators(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    GeneratorExp_get_generators(space, w_self)
    w_self.deldictvalue(space, 'generators')
    w_self.initialization_state &= ~8

_GeneratorExp_field_unroller = unrolling_iterable(['elt', 'generators'])
def GeneratorExp_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(GeneratorExp, w_self)
    w_self.w_generators = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("GeneratorExp constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _GeneratorExp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

GeneratorExp.typedef = typedef.TypeDef("GeneratorExp",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['elt', 'generators']),
    elt=typedef.GetSetProperty(GeneratorExp_get_elt, GeneratorExp_set_elt, GeneratorExp_del_elt, cls=GeneratorExp),
    generators=typedef.GetSetProperty(GeneratorExp_get_generators, GeneratorExp_set_generators, GeneratorExp_del_generators, cls=GeneratorExp),
    __new__=interp2app(get_AST_new(GeneratorExp)),
    __init__=interp2app(GeneratorExp_init),
)
GeneratorExp.typedef.heaptype = True

def Yield_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Yield_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, True)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 4

def Yield_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Yield_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

_Yield_field_unroller = unrolling_iterable(['value'])
def Yield_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Yield, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Yield constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Yield_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Yield.typedef = typedef.TypeDef("Yield",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Yield_get_value, Yield_set_value, Yield_del_value, cls=Yield),
    __new__=interp2app(get_AST_new(Yield)),
    __init__=interp2app(Yield_init),
)
Yield.typedef.heaptype = True

def Compare_get_left(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'left')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'left')
    return space.wrap(w_self.left)

def Compare_set_left(space, w_self, w_new_value):
    try:
        w_self.left = space.interp_w(expr, w_new_value, False)
        if type(w_self.left) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'left', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'left')
    w_self.initialization_state |= 4

def Compare_del_left(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Compare_get_left(space, w_self)
    w_self.deldictvalue(space, 'left')
    w_self.initialization_state &= ~4

def Compare_get_ops(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'ops')
    if w_self.w_ops is None:
        if w_self.ops is None:
            list_w = []
        else:
            list_w = [cmpop_to_class[node - 1]() for node in w_self.ops]
        w_list = space.newlist(list_w)
        w_self.w_ops = w_list
    return w_self.w_ops

def Compare_set_ops(space, w_self, w_new_value):
    w_self.w_ops = w_new_value
    w_self.initialization_state |= 8

def Compare_del_ops(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Compare_get_ops(space, w_self)
    w_self.deldictvalue(space, 'ops')
    w_self.initialization_state &= ~8

def Compare_get_comparators(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'comparators')
    if w_self.w_comparators is None:
        if w_self.comparators is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.comparators]
        w_list = space.newlist(list_w)
        w_self.w_comparators = w_list
    return w_self.w_comparators

def Compare_set_comparators(space, w_self, w_new_value):
    w_self.w_comparators = w_new_value
    w_self.initialization_state |= 16

def Compare_del_comparators(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Compare_get_comparators(space, w_self)
    w_self.deldictvalue(space, 'comparators')
    w_self.initialization_state &= ~16

_Compare_field_unroller = unrolling_iterable(['left', 'ops', 'comparators'])
def Compare_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Compare, w_self)
    w_self.w_ops = None
    w_self.w_comparators = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Compare constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Compare_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Compare.typedef = typedef.TypeDef("Compare",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['left', 'ops', 'comparators']),
    left=typedef.GetSetProperty(Compare_get_left, Compare_set_left, Compare_del_left, cls=Compare),
    ops=typedef.GetSetProperty(Compare_get_ops, Compare_set_ops, Compare_del_ops, cls=Compare),
    comparators=typedef.GetSetProperty(Compare_get_comparators, Compare_set_comparators, Compare_del_comparators, cls=Compare),
    __new__=interp2app(get_AST_new(Compare)),
    __init__=interp2app(Compare_init),
)
Compare.typedef.heaptype = True

def Call_get_func(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'func')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'func')
    return space.wrap(w_self.func)

def Call_set_func(space, w_self, w_new_value):
    try:
        w_self.func = space.interp_w(expr, w_new_value, False)
        if type(w_self.func) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'func', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'func')
    w_self.initialization_state |= 4

def Call_del_func(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Call_get_func(space, w_self)
    w_self.deldictvalue(space, 'func')
    w_self.initialization_state &= ~4

def Call_get_args(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'args')
    if w_self.w_args is None:
        if w_self.args is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.args]
        w_list = space.newlist(list_w)
        w_self.w_args = w_list
    return w_self.w_args

def Call_set_args(space, w_self, w_new_value):
    w_self.w_args = w_new_value
    w_self.initialization_state |= 8

def Call_del_args(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Call_get_args(space, w_self)
    w_self.deldictvalue(space, 'args')
    w_self.initialization_state &= ~8

def Call_get_keywords(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'keywords')
    if w_self.w_keywords is None:
        if w_self.keywords is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.keywords]
        w_list = space.newlist(list_w)
        w_self.w_keywords = w_list
    return w_self.w_keywords

def Call_set_keywords(space, w_self, w_new_value):
    w_self.w_keywords = w_new_value
    w_self.initialization_state |= 16

def Call_del_keywords(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Call_get_keywords(space, w_self)
    w_self.deldictvalue(space, 'keywords')
    w_self.initialization_state &= ~16

def Call_get_starargs(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'starargs')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 32:
        raise_attriberr(space, w_self, 'starargs')
    return space.wrap(w_self.starargs)

def Call_set_starargs(space, w_self, w_new_value):
    try:
        w_self.starargs = space.interp_w(expr, w_new_value, True)
        if type(w_self.starargs) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'starargs', w_new_value)
        w_self.initialization_state &= ~32
        return
    w_self.deldictvalue(space, 'starargs')
    w_self.initialization_state |= 32

def Call_del_starargs(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Call_get_starargs(space, w_self)
    w_self.deldictvalue(space, 'starargs')
    w_self.initialization_state &= ~32

def Call_get_kwargs(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'kwargs')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 64:
        raise_attriberr(space, w_self, 'kwargs')
    return space.wrap(w_self.kwargs)

def Call_set_kwargs(space, w_self, w_new_value):
    try:
        w_self.kwargs = space.interp_w(expr, w_new_value, True)
        if type(w_self.kwargs) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'kwargs', w_new_value)
        w_self.initialization_state &= ~64
        return
    w_self.deldictvalue(space, 'kwargs')
    w_self.initialization_state |= 64

def Call_del_kwargs(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Call_get_kwargs(space, w_self)
    w_self.deldictvalue(space, 'kwargs')
    w_self.initialization_state &= ~64

_Call_field_unroller = unrolling_iterable(['func', 'args', 'keywords', 'starargs', 'kwargs'])
def Call_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Call, w_self)
    w_self.w_args = None
    w_self.w_keywords = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Call constructor takes either 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Call_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Call.typedef = typedef.TypeDef("Call",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['func', 'args', 'keywords', 'starargs', 'kwargs']),
    func=typedef.GetSetProperty(Call_get_func, Call_set_func, Call_del_func, cls=Call),
    args=typedef.GetSetProperty(Call_get_args, Call_set_args, Call_del_args, cls=Call),
    keywords=typedef.GetSetProperty(Call_get_keywords, Call_set_keywords, Call_del_keywords, cls=Call),
    starargs=typedef.GetSetProperty(Call_get_starargs, Call_set_starargs, Call_del_starargs, cls=Call),
    kwargs=typedef.GetSetProperty(Call_get_kwargs, Call_set_kwargs, Call_del_kwargs, cls=Call),
    __new__=interp2app(get_AST_new(Call)),
    __init__=interp2app(Call_init),
)
Call.typedef.heaptype = True

def Num_get_n(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'n')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'n')
    return w_self.n

def Num_set_n(space, w_self, w_new_value):
    try:
        w_self.n = w_new_value
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'n', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'n', w_new_value)
    w_self.initialization_state |= 4

def Num_del_n(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Num_get_n(space, w_self)
    w_self.deldictvalue(space, 'n')
    w_self.initialization_state &= ~4

_Num_field_unroller = unrolling_iterable(['n'])
def Num_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Num, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Num constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Num_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Num.typedef = typedef.TypeDef("Num",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['n']),
    n=typedef.GetSetProperty(Num_get_n, Num_set_n, Num_del_n, cls=Num),
    __new__=interp2app(get_AST_new(Num)),
    __init__=interp2app(Num_init),
)
Num.typedef.heaptype = True

def Str_get_s(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 's')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 's')
    return w_self.s

def Str_set_s(space, w_self, w_new_value):
    try:
        w_self.s = check_string(space, w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 's', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 's', w_new_value)
    w_self.initialization_state |= 4

def Str_del_s(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Str_get_s(space, w_self)
    w_self.deldictvalue(space, 's')
    w_self.initialization_state &= ~4

_Str_field_unroller = unrolling_iterable(['s'])
def Str_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Str, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Str constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Str_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Str.typedef = typedef.TypeDef("Str",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['s']),
    s=typedef.GetSetProperty(Str_get_s, Str_set_s, Str_del_s, cls=Str),
    __new__=interp2app(get_AST_new(Str)),
    __init__=interp2app(Str_init),
)
Str.typedef.heaptype = True

def Bytes_get_s(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 's')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 's')
    return w_self.s

def Bytes_set_s(space, w_self, w_new_value):
    try:
        w_self.s = check_string(space, w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 's', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 's', w_new_value)
    w_self.initialization_state |= 4

def Bytes_del_s(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Bytes_get_s(space, w_self)
    w_self.deldictvalue(space, 's')
    w_self.initialization_state &= ~4

_Bytes_field_unroller = unrolling_iterable(['s'])
def Bytes_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Bytes, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Bytes constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Bytes_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Bytes.typedef = typedef.TypeDef("Bytes",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['s']),
    s=typedef.GetSetProperty(Bytes_get_s, Bytes_set_s, Bytes_del_s, cls=Bytes),
    __new__=interp2app(get_AST_new(Bytes)),
    __init__=interp2app(Bytes_init),
)
Bytes.typedef.heaptype = True

def Ellipsis_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Ellipsis, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        w_err = space.wrap("Ellipsis constructor takes no arguments")
        raise OperationError(space.w_TypeError, w_err)
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Ellipsis.typedef = typedef.TypeDef("Ellipsis",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Ellipsis)),
    __init__=interp2app(Ellipsis_init),
)
Ellipsis.typedef.heaptype = True

def Attribute_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Attribute_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 4

def Attribute_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Attribute_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

def Attribute_get_attr(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'attr')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'attr')
    if w_self.attr is None:
        return space.w_None
    return space.wrap(w_self.attr.decode('utf-8'))

def Attribute_set_attr(space, w_self, w_new_value):
    try:
        w_self.attr = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'attr', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'attr', w_new_value)
    w_self.initialization_state |= 8

def Attribute_del_attr(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Attribute_get_attr(space, w_self)
    w_self.deldictvalue(space, 'attr')
    w_self.initialization_state &= ~8

def Attribute_get_ctx(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'ctx')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'ctx')
    return expr_context_to_class[w_self.ctx - 1]()

def Attribute_set_ctx(space, w_self, w_new_value):
    try:
        obj = space.interp_w(expr_context, w_new_value)
        w_self.ctx = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'ctx', w_new_value)
        w_self.initialization_state &= ~16
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'ctx', w_new_value)
    w_self.initialization_state |= 16

def Attribute_del_ctx(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Attribute_get_ctx(space, w_self)
    w_self.deldictvalue(space, 'ctx')
    w_self.initialization_state &= ~16

_Attribute_field_unroller = unrolling_iterable(['value', 'attr', 'ctx'])
def Attribute_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Attribute, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Attribute constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Attribute_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Attribute.typedef = typedef.TypeDef("Attribute",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value', 'attr', 'ctx']),
    value=typedef.GetSetProperty(Attribute_get_value, Attribute_set_value, Attribute_del_value, cls=Attribute),
    attr=typedef.GetSetProperty(Attribute_get_attr, Attribute_set_attr, Attribute_del_attr, cls=Attribute),
    ctx=typedef.GetSetProperty(Attribute_get_ctx, Attribute_set_ctx, Attribute_del_ctx, cls=Attribute),
    __new__=interp2app(get_AST_new(Attribute)),
    __init__=interp2app(Attribute_init),
)
Attribute.typedef.heaptype = True

def Subscript_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Subscript_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 4

def Subscript_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Subscript_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

def Subscript_get_slice(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'slice')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'slice')
    return space.wrap(w_self.slice)

def Subscript_set_slice(space, w_self, w_new_value):
    try:
        w_self.slice = space.interp_w(slice, w_new_value, False)
        if type(w_self.slice) is slice:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'slice', w_new_value)
        w_self.initialization_state &= ~8
        return
    w_self.deldictvalue(space, 'slice')
    w_self.initialization_state |= 8

def Subscript_del_slice(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Subscript_get_slice(space, w_self)
    w_self.deldictvalue(space, 'slice')
    w_self.initialization_state &= ~8

def Subscript_get_ctx(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'ctx')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'ctx')
    return expr_context_to_class[w_self.ctx - 1]()

def Subscript_set_ctx(space, w_self, w_new_value):
    try:
        obj = space.interp_w(expr_context, w_new_value)
        w_self.ctx = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'ctx', w_new_value)
        w_self.initialization_state &= ~16
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'ctx', w_new_value)
    w_self.initialization_state |= 16

def Subscript_del_ctx(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Subscript_get_ctx(space, w_self)
    w_self.deldictvalue(space, 'ctx')
    w_self.initialization_state &= ~16

_Subscript_field_unroller = unrolling_iterable(['value', 'slice', 'ctx'])
def Subscript_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Subscript, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Subscript constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Subscript_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Subscript.typedef = typedef.TypeDef("Subscript",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value', 'slice', 'ctx']),
    value=typedef.GetSetProperty(Subscript_get_value, Subscript_set_value, Subscript_del_value, cls=Subscript),
    slice=typedef.GetSetProperty(Subscript_get_slice, Subscript_set_slice, Subscript_del_slice, cls=Subscript),
    ctx=typedef.GetSetProperty(Subscript_get_ctx, Subscript_set_ctx, Subscript_del_ctx, cls=Subscript),
    __new__=interp2app(get_AST_new(Subscript)),
    __init__=interp2app(Subscript_init),
)
Subscript.typedef.heaptype = True

def Starred_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Starred_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 4

def Starred_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Starred_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

def Starred_get_ctx(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'ctx')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'ctx')
    return expr_context_to_class[w_self.ctx - 1]()

def Starred_set_ctx(space, w_self, w_new_value):
    try:
        obj = space.interp_w(expr_context, w_new_value)
        w_self.ctx = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'ctx', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'ctx', w_new_value)
    w_self.initialization_state |= 8

def Starred_del_ctx(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Starred_get_ctx(space, w_self)
    w_self.deldictvalue(space, 'ctx')
    w_self.initialization_state &= ~8

_Starred_field_unroller = unrolling_iterable(['value', 'ctx'])
def Starred_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Starred, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Starred constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Starred_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Starred.typedef = typedef.TypeDef("Starred",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value', 'ctx']),
    value=typedef.GetSetProperty(Starred_get_value, Starred_set_value, Starred_del_value, cls=Starred),
    ctx=typedef.GetSetProperty(Starred_get_ctx, Starred_set_ctx, Starred_del_ctx, cls=Starred),
    __new__=interp2app(get_AST_new(Starred)),
    __init__=interp2app(Starred_init),
)
Starred.typedef.heaptype = True

def Name_get_id(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'id')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'id')
    if w_self.id is None:
        return space.w_None
    return space.wrap(w_self.id.decode('utf-8'))

def Name_set_id(space, w_self, w_new_value):
    try:
        w_self.id = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'id', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'id', w_new_value)
    w_self.initialization_state |= 4

def Name_del_id(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Name_get_id(space, w_self)
    w_self.deldictvalue(space, 'id')
    w_self.initialization_state &= ~4

def Name_get_ctx(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'ctx')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'ctx')
    return expr_context_to_class[w_self.ctx - 1]()

def Name_set_ctx(space, w_self, w_new_value):
    try:
        obj = space.interp_w(expr_context, w_new_value)
        w_self.ctx = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'ctx', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'ctx', w_new_value)
    w_self.initialization_state |= 8

def Name_del_ctx(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Name_get_ctx(space, w_self)
    w_self.deldictvalue(space, 'ctx')
    w_self.initialization_state &= ~8

_Name_field_unroller = unrolling_iterable(['id', 'ctx'])
def Name_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Name, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Name constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Name_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Name.typedef = typedef.TypeDef("Name",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['id', 'ctx']),
    id=typedef.GetSetProperty(Name_get_id, Name_set_id, Name_del_id, cls=Name),
    ctx=typedef.GetSetProperty(Name_get_ctx, Name_set_ctx, Name_del_ctx, cls=Name),
    __new__=interp2app(get_AST_new(Name)),
    __init__=interp2app(Name_init),
)
Name.typedef.heaptype = True

def List_get_elts(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'elts')
    if w_self.w_elts is None:
        if w_self.elts is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.elts]
        w_list = space.newlist(list_w)
        w_self.w_elts = w_list
    return w_self.w_elts

def List_set_elts(space, w_self, w_new_value):
    w_self.w_elts = w_new_value
    w_self.initialization_state |= 4

def List_del_elts(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    List_get_elts(space, w_self)
    w_self.deldictvalue(space, 'elts')
    w_self.initialization_state &= ~4

def List_get_ctx(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'ctx')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'ctx')
    return expr_context_to_class[w_self.ctx - 1]()

def List_set_ctx(space, w_self, w_new_value):
    try:
        obj = space.interp_w(expr_context, w_new_value)
        w_self.ctx = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'ctx', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'ctx', w_new_value)
    w_self.initialization_state |= 8

def List_del_ctx(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    List_get_ctx(space, w_self)
    w_self.deldictvalue(space, 'ctx')
    w_self.initialization_state &= ~8

_List_field_unroller = unrolling_iterable(['elts', 'ctx'])
def List_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(List, w_self)
    w_self.w_elts = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("List constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _List_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

List.typedef = typedef.TypeDef("List",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['elts', 'ctx']),
    elts=typedef.GetSetProperty(List_get_elts, List_set_elts, List_del_elts, cls=List),
    ctx=typedef.GetSetProperty(List_get_ctx, List_set_ctx, List_del_ctx, cls=List),
    __new__=interp2app(get_AST_new(List)),
    __init__=interp2app(List_init),
)
List.typedef.heaptype = True

def Tuple_get_elts(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'elts')
    if w_self.w_elts is None:
        if w_self.elts is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.elts]
        w_list = space.newlist(list_w)
        w_self.w_elts = w_list
    return w_self.w_elts

def Tuple_set_elts(space, w_self, w_new_value):
    w_self.w_elts = w_new_value
    w_self.initialization_state |= 4

def Tuple_del_elts(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Tuple_get_elts(space, w_self)
    w_self.deldictvalue(space, 'elts')
    w_self.initialization_state &= ~4

def Tuple_get_ctx(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'ctx')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'ctx')
    return expr_context_to_class[w_self.ctx - 1]()

def Tuple_set_ctx(space, w_self, w_new_value):
    try:
        obj = space.interp_w(expr_context, w_new_value)
        w_self.ctx = obj.to_simple_int(space)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'ctx', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'ctx', w_new_value)
    w_self.initialization_state |= 8

def Tuple_del_ctx(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Tuple_get_ctx(space, w_self)
    w_self.deldictvalue(space, 'ctx')
    w_self.initialization_state &= ~8

_Tuple_field_unroller = unrolling_iterable(['elts', 'ctx'])
def Tuple_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Tuple, w_self)
    w_self.w_elts = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Tuple constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Tuple_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Tuple.typedef = typedef.TypeDef("Tuple",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['elts', 'ctx']),
    elts=typedef.GetSetProperty(Tuple_get_elts, Tuple_set_elts, Tuple_del_elts, cls=Tuple),
    ctx=typedef.GetSetProperty(Tuple_get_ctx, Tuple_set_ctx, Tuple_del_ctx, cls=Tuple),
    __new__=interp2app(get_AST_new(Tuple)),
    __init__=interp2app(Tuple_init),
)
Tuple.typedef.heaptype = True

def Const_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'value')
    return w_self.value

def Const_set_value(space, w_self, w_new_value):
    try:
        w_self.value = w_new_value
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~4
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'value', w_new_value)
    w_self.initialization_state |= 4

def Const_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Const_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~4

_Const_field_unroller = unrolling_iterable(['value'])
def Const_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Const, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Const constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Const_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Const.typedef = typedef.TypeDef("Const",
    expr.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Const_get_value, Const_set_value, Const_del_value, cls=Const),
    __new__=interp2app(get_AST_new(Const)),
    __init__=interp2app(Const_init),
)
Const.typedef.heaptype = True

expr_context.typedef = typedef.TypeDef("expr_context",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(expr_context)),
)
expr_context.typedef.heaptype = True

_Load.typedef = typedef.TypeDef("Load",
    expr_context.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Load)),
)
_Load.typedef.heaptype = True

_Store.typedef = typedef.TypeDef("Store",
    expr_context.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Store)),
)
_Store.typedef.heaptype = True

_Del.typedef = typedef.TypeDef("Del",
    expr_context.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Del)),
)
_Del.typedef.heaptype = True

_AugLoad.typedef = typedef.TypeDef("AugLoad",
    expr_context.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_AugLoad)),
)
_AugLoad.typedef.heaptype = True

_AugStore.typedef = typedef.TypeDef("AugStore",
    expr_context.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_AugStore)),
)
_AugStore.typedef.heaptype = True

_Param.typedef = typedef.TypeDef("Param",
    expr_context.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Param)),
)
_Param.typedef.heaptype = True

slice.typedef = typedef.TypeDef("slice",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(slice)),
)
slice.typedef.heaptype = True

def Slice_get_lower(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'lower')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'lower')
    return space.wrap(w_self.lower)

def Slice_set_lower(space, w_self, w_new_value):
    try:
        w_self.lower = space.interp_w(expr, w_new_value, True)
        if type(w_self.lower) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'lower', w_new_value)
        w_self.initialization_state &= ~1
        return
    w_self.deldictvalue(space, 'lower')
    w_self.initialization_state |= 1

def Slice_del_lower(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Slice_get_lower(space, w_self)
    w_self.deldictvalue(space, 'lower')
    w_self.initialization_state &= ~1

def Slice_get_upper(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'upper')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'upper')
    return space.wrap(w_self.upper)

def Slice_set_upper(space, w_self, w_new_value):
    try:
        w_self.upper = space.interp_w(expr, w_new_value, True)
        if type(w_self.upper) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'upper', w_new_value)
        w_self.initialization_state &= ~2
        return
    w_self.deldictvalue(space, 'upper')
    w_self.initialization_state |= 2

def Slice_del_upper(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Slice_get_upper(space, w_self)
    w_self.deldictvalue(space, 'upper')
    w_self.initialization_state &= ~2

def Slice_get_step(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'step')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'step')
    return space.wrap(w_self.step)

def Slice_set_step(space, w_self, w_new_value):
    try:
        w_self.step = space.interp_w(expr, w_new_value, True)
        if type(w_self.step) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'step', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'step')
    w_self.initialization_state |= 4

def Slice_del_step(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Slice_get_step(space, w_self)
    w_self.deldictvalue(space, 'step')
    w_self.initialization_state &= ~4

_Slice_field_unroller = unrolling_iterable(['lower', 'upper', 'step'])
def Slice_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Slice, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Slice constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Slice_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Slice.typedef = typedef.TypeDef("Slice",
    slice.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['lower', 'upper', 'step']),
    lower=typedef.GetSetProperty(Slice_get_lower, Slice_set_lower, Slice_del_lower, cls=Slice),
    upper=typedef.GetSetProperty(Slice_get_upper, Slice_set_upper, Slice_del_upper, cls=Slice),
    step=typedef.GetSetProperty(Slice_get_step, Slice_set_step, Slice_del_step, cls=Slice),
    __new__=interp2app(get_AST_new(Slice)),
    __init__=interp2app(Slice_init),
)
Slice.typedef.heaptype = True

def ExtSlice_get_dims(space, w_self):
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'dims')
    if w_self.w_dims is None:
        if w_self.dims is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.dims]
        w_list = space.newlist(list_w)
        w_self.w_dims = w_list
    return w_self.w_dims

def ExtSlice_set_dims(space, w_self, w_new_value):
    w_self.w_dims = w_new_value
    w_self.initialization_state |= 1

def ExtSlice_del_dims(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ExtSlice_get_dims(space, w_self)
    w_self.deldictvalue(space, 'dims')
    w_self.initialization_state &= ~1

_ExtSlice_field_unroller = unrolling_iterable(['dims'])
def ExtSlice_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(ExtSlice, w_self)
    w_self.w_dims = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("ExtSlice constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ExtSlice_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

ExtSlice.typedef = typedef.TypeDef("ExtSlice",
    slice.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['dims']),
    dims=typedef.GetSetProperty(ExtSlice_get_dims, ExtSlice_set_dims, ExtSlice_del_dims, cls=ExtSlice),
    __new__=interp2app(get_AST_new(ExtSlice)),
    __init__=interp2app(ExtSlice_init),
)
ExtSlice.typedef.heaptype = True

def Index_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def Index_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~1
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 1

def Index_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    Index_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~1

_Index_field_unroller = unrolling_iterable(['value'])
def Index_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(Index, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Index constructor takes either 0 or 1 positional argument")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Index_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

Index.typedef = typedef.TypeDef("Index",
    slice.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Index_get_value, Index_set_value, Index_del_value, cls=Index),
    __new__=interp2app(get_AST_new(Index)),
    __init__=interp2app(Index_init),
)
Index.typedef.heaptype = True

boolop.typedef = typedef.TypeDef("boolop",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(boolop)),
)
boolop.typedef.heaptype = True

_And.typedef = typedef.TypeDef("And",
    boolop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_And)),
)
_And.typedef.heaptype = True

_Or.typedef = typedef.TypeDef("Or",
    boolop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Or)),
)
_Or.typedef.heaptype = True

operator.typedef = typedef.TypeDef("operator",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(operator)),
)
operator.typedef.heaptype = True

_Add.typedef = typedef.TypeDef("Add",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Add)),
)
_Add.typedef.heaptype = True

_Sub.typedef = typedef.TypeDef("Sub",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Sub)),
)
_Sub.typedef.heaptype = True

_Mult.typedef = typedef.TypeDef("Mult",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Mult)),
)
_Mult.typedef.heaptype = True

_Div.typedef = typedef.TypeDef("Div",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Div)),
)
_Div.typedef.heaptype = True

_Mod.typedef = typedef.TypeDef("Mod",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Mod)),
)
_Mod.typedef.heaptype = True

_Pow.typedef = typedef.TypeDef("Pow",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Pow)),
)
_Pow.typedef.heaptype = True

_LShift.typedef = typedef.TypeDef("LShift",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_LShift)),
)
_LShift.typedef.heaptype = True

_RShift.typedef = typedef.TypeDef("RShift",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_RShift)),
)
_RShift.typedef.heaptype = True

_BitOr.typedef = typedef.TypeDef("BitOr",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_BitOr)),
)
_BitOr.typedef.heaptype = True

_BitXor.typedef = typedef.TypeDef("BitXor",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_BitXor)),
)
_BitXor.typedef.heaptype = True

_BitAnd.typedef = typedef.TypeDef("BitAnd",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_BitAnd)),
)
_BitAnd.typedef.heaptype = True

_FloorDiv.typedef = typedef.TypeDef("FloorDiv",
    operator.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_FloorDiv)),
)
_FloorDiv.typedef.heaptype = True

unaryop.typedef = typedef.TypeDef("unaryop",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(unaryop)),
)
unaryop.typedef.heaptype = True

_Invert.typedef = typedef.TypeDef("Invert",
    unaryop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Invert)),
)
_Invert.typedef.heaptype = True

_Not.typedef = typedef.TypeDef("Not",
    unaryop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Not)),
)
_Not.typedef.heaptype = True

_UAdd.typedef = typedef.TypeDef("UAdd",
    unaryop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_UAdd)),
)
_UAdd.typedef.heaptype = True

_USub.typedef = typedef.TypeDef("USub",
    unaryop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_USub)),
)
_USub.typedef.heaptype = True

cmpop.typedef = typedef.TypeDef("cmpop",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(cmpop)),
)
cmpop.typedef.heaptype = True

_Eq.typedef = typedef.TypeDef("Eq",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Eq)),
)
_Eq.typedef.heaptype = True

_NotEq.typedef = typedef.TypeDef("NotEq",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_NotEq)),
)
_NotEq.typedef.heaptype = True

_Lt.typedef = typedef.TypeDef("Lt",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Lt)),
)
_Lt.typedef.heaptype = True

_LtE.typedef = typedef.TypeDef("LtE",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_LtE)),
)
_LtE.typedef.heaptype = True

_Gt.typedef = typedef.TypeDef("Gt",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Gt)),
)
_Gt.typedef.heaptype = True

_GtE.typedef = typedef.TypeDef("GtE",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_GtE)),
)
_GtE.typedef.heaptype = True

_Is.typedef = typedef.TypeDef("Is",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Is)),
)
_Is.typedef.heaptype = True

_IsNot.typedef = typedef.TypeDef("IsNot",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_IsNot)),
)
_IsNot.typedef.heaptype = True

_In.typedef = typedef.TypeDef("In",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_In)),
)
_In.typedef.heaptype = True

_NotIn.typedef = typedef.TypeDef("NotIn",
    cmpop.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_NotIn)),
)
_NotIn.typedef.heaptype = True

def comprehension_get_target(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'target')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'target')
    return space.wrap(w_self.target)

def comprehension_set_target(space, w_self, w_new_value):
    try:
        w_self.target = space.interp_w(expr, w_new_value, False)
        if type(w_self.target) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'target', w_new_value)
        w_self.initialization_state &= ~1
        return
    w_self.deldictvalue(space, 'target')
    w_self.initialization_state |= 1

def comprehension_del_target(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    comprehension_get_target(space, w_self)
    w_self.deldictvalue(space, 'target')
    w_self.initialization_state &= ~1

def comprehension_get_iter(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'iter')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'iter')
    return space.wrap(w_self.iter)

def comprehension_set_iter(space, w_self, w_new_value):
    try:
        w_self.iter = space.interp_w(expr, w_new_value, False)
        if type(w_self.iter) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'iter', w_new_value)
        w_self.initialization_state &= ~2
        return
    w_self.deldictvalue(space, 'iter')
    w_self.initialization_state |= 2

def comprehension_del_iter(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    comprehension_get_iter(space, w_self)
    w_self.deldictvalue(space, 'iter')
    w_self.initialization_state &= ~2

def comprehension_get_ifs(space, w_self):
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'ifs')
    if w_self.w_ifs is None:
        if w_self.ifs is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.ifs]
        w_list = space.newlist(list_w)
        w_self.w_ifs = w_list
    return w_self.w_ifs

def comprehension_set_ifs(space, w_self, w_new_value):
    w_self.w_ifs = w_new_value
    w_self.initialization_state |= 4

def comprehension_del_ifs(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    comprehension_get_ifs(space, w_self)
    w_self.deldictvalue(space, 'ifs')
    w_self.initialization_state &= ~4

_comprehension_field_unroller = unrolling_iterable(['target', 'iter', 'ifs'])
def comprehension_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(comprehension, w_self)
    w_self.w_ifs = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("comprehension constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _comprehension_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

comprehension.typedef = typedef.TypeDef("comprehension",
    AST.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['target', 'iter', 'ifs']),
    target=typedef.GetSetProperty(comprehension_get_target, comprehension_set_target, comprehension_del_target, cls=comprehension),
    iter=typedef.GetSetProperty(comprehension_get_iter, comprehension_set_iter, comprehension_del_iter, cls=comprehension),
    ifs=typedef.GetSetProperty(comprehension_get_ifs, comprehension_set_ifs, comprehension_del_ifs, cls=comprehension),
    __new__=interp2app(get_AST_new(comprehension)),
    __init__=interp2app(comprehension_init),
)
comprehension.typedef.heaptype = True

def excepthandler_get_lineno(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'lineno')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'lineno')
    return space.wrap(w_self.lineno)

def excepthandler_set_lineno(space, w_self, w_new_value):
    try:
        w_self.lineno = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'lineno', w_new_value)
        w_self.initialization_state &= ~1
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'lineno', w_new_value)
    w_self.initialization_state |= 1

def excepthandler_del_lineno(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    excepthandler_get_lineno(space, w_self)
    w_self.deldictvalue(space, 'lineno')
    w_self.initialization_state &= ~1

def excepthandler_get_col_offset(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'col_offset')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'col_offset')
    return space.wrap(w_self.col_offset)

def excepthandler_set_col_offset(space, w_self, w_new_value):
    try:
        w_self.col_offset = space.int_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'col_offset', w_new_value)
        w_self.initialization_state &= ~2
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'col_offset', w_new_value)
    w_self.initialization_state |= 2

def excepthandler_del_col_offset(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    excepthandler_get_col_offset(space, w_self)
    w_self.deldictvalue(space, 'col_offset')
    w_self.initialization_state &= ~2

excepthandler.typedef = typedef.TypeDef("excepthandler",
    AST.typedef,
    __module__='_ast',
    _attributes=_FieldsWrapper(['lineno', 'col_offset']),
    lineno=typedef.GetSetProperty(excepthandler_get_lineno, excepthandler_set_lineno, excepthandler_del_lineno, cls=excepthandler),
    col_offset=typedef.GetSetProperty(excepthandler_get_col_offset, excepthandler_set_col_offset, excepthandler_del_col_offset, cls=excepthandler),
    __new__=interp2app(get_AST_new(excepthandler)),
)
excepthandler.typedef.heaptype = True

def ExceptHandler_get_type(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'type')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'type')
    return space.wrap(w_self.type)

def ExceptHandler_set_type(space, w_self, w_new_value):
    try:
        w_self.type = space.interp_w(expr, w_new_value, True)
        if type(w_self.type) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'type', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'type')
    w_self.initialization_state |= 4

def ExceptHandler_del_type(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ExceptHandler_get_type(space, w_self)
    w_self.deldictvalue(space, 'type')
    w_self.initialization_state &= ~4

def ExceptHandler_get_name(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'name')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'name')
    if w_self.name is None:
        return space.w_None
    return space.wrap(w_self.name.decode('utf-8'))

def ExceptHandler_set_name(space, w_self, w_new_value):
    try:
        if space.is_w(w_new_value, space.w_None):
            w_self.name = None
        else:
            w_self.name = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'name', w_new_value)
        w_self.initialization_state &= ~8
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'name', w_new_value)
    w_self.initialization_state |= 8

def ExceptHandler_del_name(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ExceptHandler_get_name(space, w_self)
    w_self.deldictvalue(space, 'name')
    w_self.initialization_state &= ~8

def ExceptHandler_get_body(space, w_self):
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'body')
    if w_self.w_body is None:
        if w_self.body is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.body]
        w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def ExceptHandler_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 16

def ExceptHandler_del_body(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    ExceptHandler_get_body(space, w_self)
    w_self.deldictvalue(space, 'body')
    w_self.initialization_state &= ~16

_ExceptHandler_field_unroller = unrolling_iterable(['type', 'name', 'body'])
def ExceptHandler_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(ExceptHandler, w_self)
    w_self.w_body = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("ExceptHandler constructor takes either 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ExceptHandler_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

ExceptHandler.typedef = typedef.TypeDef("ExceptHandler",
    excepthandler.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['type', 'name', 'body']),
    type=typedef.GetSetProperty(ExceptHandler_get_type, ExceptHandler_set_type, ExceptHandler_del_type, cls=ExceptHandler),
    name=typedef.GetSetProperty(ExceptHandler_get_name, ExceptHandler_set_name, ExceptHandler_del_name, cls=ExceptHandler),
    body=typedef.GetSetProperty(ExceptHandler_get_body, ExceptHandler_set_body, ExceptHandler_del_body, cls=ExceptHandler),
    __new__=interp2app(get_AST_new(ExceptHandler)),
    __init__=interp2app(ExceptHandler_init),
)
ExceptHandler.typedef.heaptype = True

def arguments_get_args(space, w_self):
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'args')
    if w_self.w_args is None:
        if w_self.args is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.args]
        w_list = space.newlist(list_w)
        w_self.w_args = w_list
    return w_self.w_args

def arguments_set_args(space, w_self, w_new_value):
    w_self.w_args = w_new_value
    w_self.initialization_state |= 1

def arguments_del_args(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_args(space, w_self)
    w_self.deldictvalue(space, 'args')
    w_self.initialization_state &= ~1

def arguments_get_vararg(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'vararg')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'vararg')
    if w_self.vararg is None:
        return space.w_None
    return space.wrap(w_self.vararg.decode('utf-8'))

def arguments_set_vararg(space, w_self, w_new_value):
    try:
        if space.is_w(w_new_value, space.w_None):
            w_self.vararg = None
        else:
            w_self.vararg = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'vararg', w_new_value)
        w_self.initialization_state &= ~2
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'vararg', w_new_value)
    w_self.initialization_state |= 2

def arguments_del_vararg(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_vararg(space, w_self)
    w_self.deldictvalue(space, 'vararg')
    w_self.initialization_state &= ~2

def arguments_get_varargannotation(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'varargannotation')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 4:
        raise_attriberr(space, w_self, 'varargannotation')
    return space.wrap(w_self.varargannotation)

def arguments_set_varargannotation(space, w_self, w_new_value):
    try:
        w_self.varargannotation = space.interp_w(expr, w_new_value, True)
        if type(w_self.varargannotation) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'varargannotation', w_new_value)
        w_self.initialization_state &= ~4
        return
    w_self.deldictvalue(space, 'varargannotation')
    w_self.initialization_state |= 4

def arguments_del_varargannotation(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_varargannotation(space, w_self)
    w_self.deldictvalue(space, 'varargannotation')
    w_self.initialization_state &= ~4

def arguments_get_kwonlyargs(space, w_self):
    if not w_self.initialization_state & 8:
        raise_attriberr(space, w_self, 'kwonlyargs')
    if w_self.w_kwonlyargs is None:
        if w_self.kwonlyargs is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.kwonlyargs]
        w_list = space.newlist(list_w)
        w_self.w_kwonlyargs = w_list
    return w_self.w_kwonlyargs

def arguments_set_kwonlyargs(space, w_self, w_new_value):
    w_self.w_kwonlyargs = w_new_value
    w_self.initialization_state |= 8

def arguments_del_kwonlyargs(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_kwonlyargs(space, w_self)
    w_self.deldictvalue(space, 'kwonlyargs')
    w_self.initialization_state &= ~8

def arguments_get_kwarg(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'kwarg')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 16:
        raise_attriberr(space, w_self, 'kwarg')
    if w_self.kwarg is None:
        return space.w_None
    return space.wrap(w_self.kwarg.decode('utf-8'))

def arguments_set_kwarg(space, w_self, w_new_value):
    try:
        if space.is_w(w_new_value, space.w_None):
            w_self.kwarg = None
        else:
            w_self.kwarg = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'kwarg', w_new_value)
        w_self.initialization_state &= ~16
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'kwarg', w_new_value)
    w_self.initialization_state |= 16

def arguments_del_kwarg(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_kwarg(space, w_self)
    w_self.deldictvalue(space, 'kwarg')
    w_self.initialization_state &= ~16

def arguments_get_kwargannotation(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'kwargannotation')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 32:
        raise_attriberr(space, w_self, 'kwargannotation')
    return space.wrap(w_self.kwargannotation)

def arguments_set_kwargannotation(space, w_self, w_new_value):
    try:
        w_self.kwargannotation = space.interp_w(expr, w_new_value, True)
        if type(w_self.kwargannotation) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'kwargannotation', w_new_value)
        w_self.initialization_state &= ~32
        return
    w_self.deldictvalue(space, 'kwargannotation')
    w_self.initialization_state |= 32

def arguments_del_kwargannotation(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_kwargannotation(space, w_self)
    w_self.deldictvalue(space, 'kwargannotation')
    w_self.initialization_state &= ~32

def arguments_get_defaults(space, w_self):
    if not w_self.initialization_state & 64:
        raise_attriberr(space, w_self, 'defaults')
    if w_self.w_defaults is None:
        if w_self.defaults is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.defaults]
        w_list = space.newlist(list_w)
        w_self.w_defaults = w_list
    return w_self.w_defaults

def arguments_set_defaults(space, w_self, w_new_value):
    w_self.w_defaults = w_new_value
    w_self.initialization_state |= 64

def arguments_del_defaults(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_defaults(space, w_self)
    w_self.deldictvalue(space, 'defaults')
    w_self.initialization_state &= ~64

def arguments_get_kw_defaults(space, w_self):
    if not w_self.initialization_state & 128:
        raise_attriberr(space, w_self, 'kw_defaults')
    if w_self.w_kw_defaults is None:
        if w_self.kw_defaults is None:
            list_w = []
        else:
            list_w = [space.wrap(node) for node in w_self.kw_defaults]
        w_list = space.newlist(list_w)
        w_self.w_kw_defaults = w_list
    return w_self.w_kw_defaults

def arguments_set_kw_defaults(space, w_self, w_new_value):
    w_self.w_kw_defaults = w_new_value
    w_self.initialization_state |= 128

def arguments_del_kw_defaults(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arguments_get_kw_defaults(space, w_self)
    w_self.deldictvalue(space, 'kw_defaults')
    w_self.initialization_state &= ~128

_arguments_field_unroller = unrolling_iterable(['args', 'vararg', 'varargannotation', 'kwonlyargs', 'kwarg', 'kwargannotation', 'defaults', 'kw_defaults'])
def arguments_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(arguments, w_self)
    w_self.w_args = None
    w_self.w_kwonlyargs = None
    w_self.w_defaults = None
    w_self.w_kw_defaults = None
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 8:
            w_err = space.wrap("arguments constructor takes either 0 or 8 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _arguments_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

arguments.typedef = typedef.TypeDef("arguments",
    AST.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['args', 'vararg', 'varargannotation', 'kwonlyargs', 'kwarg', 'kwargannotation', 'defaults', 'kw_defaults']),
    args=typedef.GetSetProperty(arguments_get_args, arguments_set_args, arguments_del_args, cls=arguments),
    vararg=typedef.GetSetProperty(arguments_get_vararg, arguments_set_vararg, arguments_del_vararg, cls=arguments),
    varargannotation=typedef.GetSetProperty(arguments_get_varargannotation, arguments_set_varargannotation, arguments_del_varargannotation, cls=arguments),
    kwonlyargs=typedef.GetSetProperty(arguments_get_kwonlyargs, arguments_set_kwonlyargs, arguments_del_kwonlyargs, cls=arguments),
    kwarg=typedef.GetSetProperty(arguments_get_kwarg, arguments_set_kwarg, arguments_del_kwarg, cls=arguments),
    kwargannotation=typedef.GetSetProperty(arguments_get_kwargannotation, arguments_set_kwargannotation, arguments_del_kwargannotation, cls=arguments),
    defaults=typedef.GetSetProperty(arguments_get_defaults, arguments_set_defaults, arguments_del_defaults, cls=arguments),
    kw_defaults=typedef.GetSetProperty(arguments_get_kw_defaults, arguments_set_kw_defaults, arguments_del_kw_defaults, cls=arguments),
    __new__=interp2app(get_AST_new(arguments)),
    __init__=interp2app(arguments_init),
)
arguments.typedef.heaptype = True

def arg_get_arg(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'arg')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'arg')
    if w_self.arg is None:
        return space.w_None
    return space.wrap(w_self.arg.decode('utf-8'))

def arg_set_arg(space, w_self, w_new_value):
    try:
        w_self.arg = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'arg', w_new_value)
        w_self.initialization_state &= ~1
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'arg', w_new_value)
    w_self.initialization_state |= 1

def arg_del_arg(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arg_get_arg(space, w_self)
    w_self.deldictvalue(space, 'arg')
    w_self.initialization_state &= ~1

def arg_get_annotation(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'annotation')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'annotation')
    return space.wrap(w_self.annotation)

def arg_set_annotation(space, w_self, w_new_value):
    try:
        w_self.annotation = space.interp_w(expr, w_new_value, True)
        if type(w_self.annotation) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'annotation', w_new_value)
        w_self.initialization_state &= ~2
        return
    w_self.deldictvalue(space, 'annotation')
    w_self.initialization_state |= 2

def arg_del_annotation(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    arg_get_annotation(space, w_self)
    w_self.deldictvalue(space, 'annotation')
    w_self.initialization_state &= ~2

_arg_field_unroller = unrolling_iterable(['arg', 'annotation'])
def arg_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(arg, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("arg constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _arg_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

arg.typedef = typedef.TypeDef("arg",
    AST.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['arg', 'annotation']),
    arg=typedef.GetSetProperty(arg_get_arg, arg_set_arg, arg_del_arg, cls=arg),
    annotation=typedef.GetSetProperty(arg_get_annotation, arg_set_annotation, arg_del_annotation, cls=arg),
    __new__=interp2app(get_AST_new(arg)),
    __init__=interp2app(arg_init),
)
arg.typedef.heaptype = True

def keyword_get_arg(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'arg')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'arg')
    if w_self.arg is None:
        return space.w_None
    return space.wrap(w_self.arg.decode('utf-8'))

def keyword_set_arg(space, w_self, w_new_value):
    try:
        w_self.arg = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'arg', w_new_value)
        w_self.initialization_state &= ~1
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'arg', w_new_value)
    w_self.initialization_state |= 1

def keyword_del_arg(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    keyword_get_arg(space, w_self)
    w_self.deldictvalue(space, 'arg')
    w_self.initialization_state &= ~1

def keyword_get_value(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'value')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'value')
    return space.wrap(w_self.value)

def keyword_set_value(space, w_self, w_new_value):
    try:
        w_self.value = space.interp_w(expr, w_new_value, False)
        if type(w_self.value) is expr:
            raise OperationError(space.w_TypeError, space.w_None)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'value', w_new_value)
        w_self.initialization_state &= ~2
        return
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state |= 2

def keyword_del_value(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    keyword_get_value(space, w_self)
    w_self.deldictvalue(space, 'value')
    w_self.initialization_state &= ~2

_keyword_field_unroller = unrolling_iterable(['arg', 'value'])
def keyword_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(keyword, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("keyword constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _keyword_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

keyword.typedef = typedef.TypeDef("keyword",
    AST.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['arg', 'value']),
    arg=typedef.GetSetProperty(keyword_get_arg, keyword_set_arg, keyword_del_arg, cls=keyword),
    value=typedef.GetSetProperty(keyword_get_value, keyword_set_value, keyword_del_value, cls=keyword),
    __new__=interp2app(get_AST_new(keyword)),
    __init__=interp2app(keyword_init),
)
keyword.typedef.heaptype = True

def alias_get_name(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'name')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 1:
        raise_attriberr(space, w_self, 'name')
    if w_self.name is None:
        return space.w_None
    return space.wrap(w_self.name.decode('utf-8'))

def alias_set_name(space, w_self, w_new_value):
    try:
        w_self.name = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'name', w_new_value)
        w_self.initialization_state &= ~1
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'name', w_new_value)
    w_self.initialization_state |= 1

def alias_del_name(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    alias_get_name(space, w_self)
    w_self.deldictvalue(space, 'name')
    w_self.initialization_state &= ~1

def alias_get_asname(space, w_self):
    if w_self.w_dict is not None:
        w_obj = w_self.getdictvalue(space, 'asname')
        if w_obj is not None:
            return w_obj
    if not w_self.initialization_state & 2:
        raise_attriberr(space, w_self, 'asname')
    if w_self.asname is None:
        return space.w_None
    return space.wrap(w_self.asname.decode('utf-8'))

def alias_set_asname(space, w_self, w_new_value):
    try:
        if space.is_w(w_new_value, space.w_None):
            w_self.asname = None
        else:
            w_self.asname = space.identifier_w(w_new_value)
    except OperationError, e:
        if not e.match(space, space.w_TypeError):
            raise
        w_self.setdictvalue(space, 'asname', w_new_value)
        w_self.initialization_state &= ~2
        return
    # need to save the original object too
    w_self.setdictvalue(space, 'asname', w_new_value)
    w_self.initialization_state |= 2

def alias_del_asname(space, w_self):
    # Check if the element exists, raise appropriate exceptions
    alias_get_asname(space, w_self)
    w_self.deldictvalue(space, 'asname')
    w_self.initialization_state &= ~2

_alias_field_unroller = unrolling_iterable(['name', 'asname'])
def alias_init(space, w_self, __args__):
    w_self = space.descr_self_interp_w(alias, w_self)
    args_w, kwargs_w = __args__.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("alias constructor takes either 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _alias_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)

alias.typedef = typedef.TypeDef("alias",
    AST.typedef,
    __module__='_ast',
    _fields=_FieldsWrapper(['name', 'asname']),
    name=typedef.GetSetProperty(alias_get_name, alias_set_name, alias_del_name, cls=alias),
    asname=typedef.GetSetProperty(alias_get_asname, alias_set_asname, alias_del_asname, cls=alias),
    __new__=interp2app(get_AST_new(alias)),
    __init__=interp2app(alias_init),
)
alias.typedef.heaptype = True

=======
>>>>>>> theirs
